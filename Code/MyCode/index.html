<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Document-Based Process Modeller</title>
  <!-- libs, do not modify. When local than load local libs. -->
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.min.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.browser.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.caret.min.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.cookie.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.svg.min.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/jquery.svgdom.min.js"></script>

  <!-- <script type="text/javascript" src="/js_libs/build-bpmn.js"></script> -->
  <script type="text/javascript" src="js_libs/custommenu.js"></script>
  <!-- <script type="text/javascript" src="js_libs/marked.min.js"></script> -->
  <script type="text/javascript" src="js_libs/parsequery.js"></script>
  <script type="text/javascript" src="js_libs/printf.js"></script>
  <script type="text/javascript" src="js_libs/relaxngui.js"></script>
  <script type="text/javascript" src="js_libs/strftime.min.js"></script>
  <script type="text/javascript" src="js_libs/uidash.js"></script>
  <script type="text/javascript" src="js_libs/underscore.min.js"></script>
  <script type="text/javascript" src="js_libs/util.js"></script>
  <script type="text/javascript" src="js_libs/vkbeautify.js"></script>

  <link rel="stylesheet" href="js_libs/custommenu.css" type="text/css" />
  <link rel="stylesheet" href="js_libs/relaxngui.css" type="text/css">
  <link rel="stylesheet" href="js_libs/uidash.css" type="text/css">
  <link rel="stylesheet" href="js_libs/uidash-icons.css" type="text/css">

  <link rel="stylesheet" href="css/ui.css" type="text/css">
  <link rel="stylesheet" href="css/globalui_cpee.css" type="text/css">

  <!-- modelling ui -->
  <script type="text/javascript" src="js/wfadaptor.js"></script>
  <link rel="stylesheet" href="css/wfadaptor.css" type="text/css" />
  <script type="text/javascript" src="themes/base.js"></script>

  <script type="text/javascript" src="js/extended_columns.js"></script>
  <link rel="stylesheet" href="css/extended_columns-label.css" type="text/css" />
  <link rel="stylesheet" href="css/extended_columns-svg.css" type="text/css" />

  <!-- Flos Stuff -->
  <!-- <script type="text/javascript" src="js/structured.js"></script> -->
  <!-- <style type="text/css">
    @font-face {
      font-family: TencentSans;
      src: url("chrome-extension://lkjkfecdnfjopaeaibboihfkmhdjmanm/static/fonts/TencentSans.woff2");
    }
  </style> -->

  <!-- my libs-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- my scripts - DB simulation -->
  <script src="js/db_documents.js"></script>
  <script src="js/db_models.js"></script>
  <script src="js/db_traces.js"></script>
  <!-- my ui-->
  <link rel="stylesheet" href="css/myui.css" type="text/css" />

</head>
<body data-defaultconfig="index.json" is="x-ui-" data-names="3">
  <ui-rest style="z-index: 2;">
    <ui-content>
      <!-- Left: Document Panel -->
      <ui-rest style="flex:2;">
        <!-- Document List Pane -->
        <ui-tabbed style="z-index: 2;">
          <ui-tabbar>
            <ui-tab class="switch"></ui-tab>
            <ui-tab class="" data-tab="documents" id="tabdocuments" style="flex: 1;">Documents</ui-tab>
          </ui-tabbar>
          <ui-content>
            <ui-area data-belongs-to-tab="documents" id="areadocuments">
              <ul id="documentList">
              </ul>
              <label for="documentsInput">Choose documents to upload</label>
              <input type="file" id="documentsInput" multiple />
            </ui-area>
          </ui-content>
        </ui-tabbed>
        <!-- Text Action Bar -->
        <ui-area id="tracesLayer" style="z-index: 1;"></ui-area>
        <ui-area id="temporarySelectionsLayer" style="z-index: 1;"></ui-area>
        <button id="deleteSelectionButton"
          style="display:none; position:absolute;  z-index:3; width: 24px; height: 24px; background-color: red; color: white;border: none; border-radius: 50%; font-weight: bold;cursor: pointer;">X</button>

        <!-- Document Viewer -->
        <ui-rest class="panel" style="margin:0.5em;">

          <ui-content>
            <ui-area id="documentContent">
            </ui-area>
          </ui-content>

          <div class="bottom-bar" z-index="3">
            <div class="button-group">
              <button id="generateButton" disabled="true">Generate Model</button>
              <button id="regenerateButton" style="display:none;">Regenerate</button>
            </div>
          </div>
        </ui-rest>
      </ui-rest>
      <ui-resizehandle data-label="drag to resize"></ui-resizehandle>
      <!-- Middle: Current Model Panel -->
      <ui-rest class="panel" style="flex:2; margin: .5em 0;">
        <div id="activeModelName"></div>
        <!-- <div>
          <label for="hr-select">Your favorite food</label> <br />

          <select name="foods" id="hr-select">
            <option value="">Choose a food</option>
            <hr />
            <optgroup label="Fruit">
              <option value="apple">Apples</option>
              <option value="banana">Bananas</option>
              <option value="cherry">Cherries</option>
              <option value="damson">Damsons</option>
            </optgroup>
            <hr />
            <optgroup label="Vegetables">
              <option value="artichoke">Artichokes</option>
              <option value="broccoli">Broccoli</option>
              <option value="cabbage">Cabbages</option>
            </optgroup>
            <hr />
            <optgroup label="Meat">
              <option value="beef">Beef</option>
              <option value="chicken">Chicken</option>
              <option value="pork">Pork</option>
            </optgroup>
            <hr />
            <optgroup label="Fish">
              <option value="cod">Cod</option>
              <option value="haddock">Haddock</option>
              <option value="salmon">Salmon</option>
              <option value="turbot">Turbot</option>
            </optgroup>
          </select>
        </div> -->
        <button name="savemodelchanges" onclick="saveModel()">Save Model</button>
        <div>
          <!-- <a id=" savetestsetfile" href="" download=""></a>
          <a id="savesvgfile" href="" download=""></a>
          <button title='a testset includes various settings, subscriptions and a model'
            name="savetestsetfile">save<br>testset</button>
          <button title='the SVG contains the graphical repesentation of the CPEE tree as you see it on the screen'
            name="savesvgfile">save svg<br>graph</button> -->
        </div>
        <ui-content>
          <div id='activeModelGrid'>
            <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink"
              id='activeModelCanvas' width='1' height='1'></svg>
          </div>

          <div id="relaxngworker"></div>
          <ui-area data-belongs-to-tab="details" id="detailcolumn">
            <div id="dat_details" class='x-ui-layout'></div>
          </ui-area>
        </ui-content>
        <!-- Model Action Bar -->
        <div id="generatedModelActionBar" class="bottom-bar" style="visibility: hidden;">
          <div class="button-group">
            <button id="cancelButton">Cancel</button>
            <button id="keepButton">Keep</button>
          </div>
        </div>

      </ui-rest>
      <ui-resizehandle data-label="drag to resize"></ui-resizehandle>
      <!-- Right: Models Panel-->

      <ui-rest style="flex:1; margin:0.5em; padding: .2em;" class="panel">
        <ui-tab>Models</ui-tab>
        <ui-rest>
          <ui-content>
            <ui-area id="models">
              <div id='activeModelCanvasSmallContainer' style="position: absolute; left: -9999px; top: -9999px;">
                <div id='activeModelGridSmall'>
                  <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink"
                    id='activeModelCanvasSmall' width='1' height='1'></svg>
                </div>
              </div>
            </ui-area>
          </ui-content>

        </ui-rest>
      </ui-rest>

    </ui-content>
  </ui-rest>
  <script>
    const $window = $(window);
    const $document = $(document);
    const $documentsInput = $('#documentsInput');
    const $documentList = $('#documentList');

    const $documentContent = $('#documentContent');

    const $tracesLayer = $('#tracesLayer');
    const $temporarySelectionsLayer = $('#temporarySelectionsLayer');

    const $deleteSelectionButton = $('#deleteSelectionButton');
    const $generateButton = $('#generateButton');
    const $regenerateButton = $('#regenerateButton');
    const $keepButton = $('#keepButton');
    const $cancelButton = $('#cancelButton');

    const $modelsArea = $("#models");

    let db;
    let documentList = [];
    let activeDocId = null;
    let traces = [];
    let models = [];
    let activeModel = null;

    let temporarySelections = [];

    const getActiveModelId = () => {
      return activeModel ? activeModel.id : null;
    };

    const getActiveModelTrace = () => {
      return traces.find(trace => trace.model_id == (activeModel && activeModel.id)) || null;
    };
    const getActiveModelDocumentId = () => {
      const trace = getActiveModelTrace();
      return trace ? trace.document_id : null;
    };

    const getDocumentTraces = (docId) => {
      return traces.filter(trace => trace.document_id == docId);
    };
    const deleteDocumentTraces = (docId) => {
      traces = traces.filter(trace => trace.document_id != docId);
    };

    // #region CPEE Code
    var es;
    var suspended_redrawing = false;
    var skip_location = false;
    var myid = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    var paths = '#dat_details input, #dat_details textarea, #dat_details select, #dat_details button, #dat_details [contenteditable], #dat_dataelements input, #dat_dataelements textarea, #dat_dataelements select, #dat_dataelements button, #dat_dataelements [contenteditable], #dat_endpoints input, #dat_endpoints textarea, #dat_endpoints select, #dat_endpoints button, #dat_endpoints [contenteditable], #dat_attributes input, #dat_attributes textarea, #dat_attributes select, #dat_attributes button, #dat_attributes [contenteditable]';
    var loading = false;
    var subscription;
    var subscription_state = 'less';
    var graph_changed = new Event("graph:changed", { "bubbles": true, "cancelable": false });
    var graph_theme = null;
    var graph_position = null;
    var graph_highlight = null;
    var graph_highlight_tasks = []
    var graph_highlight_color = null;
    var model_loaded = new Event("model:loaded", { "bubbles": true, "cancelable": false });
    var save = {};
    save['endpoints'] = undefined;
    save['dataelements'] = undefined;
    save['attributes'] = undefined;
    save['attributes_raw'] = {};

    var node_state = {};
    var debug = false;

    function global_init() {
      suspended_redrawing = false;
      loading = false;
      subscription = undefined;
      subscription_state = 'less';
      save['states'] = {};
      save['state'] = "ready";
      save['dsl'] = undefined;
      save['activity_red_states'] = {}
      save['graph'] = undefined;
      save['graph_theme'] = undefined;
      save['graph_adaptor'] = undefined;
      save['endpoints_cache'] = {};
      save['endpoints_list'] = {};
      save['details'] = undefined;
      save['details_target'] = {};
      save['instance_pos'] = [];
      save['modeltype'] = 'CPEE';
      save['modifiers'] = {};
      save['modifiers_active'] = {};
      save['modifiers_additional'] = {};
      save['resources'] = undefined;
      node_state = {};
    }

    global_init();

    function format_visual_forms() {
      // if (save['state'] != "ready" && save['state'] != "stopped") {
      //   $(paths).each(function (k, e) {
      //     if ($(e).attr('contenteditable')) { $(e).attr('contenteditable', 'false'); }
      //     $(e).attr('disabled', 'disable');
      //   });
      // } else {
      //   $(paths).each(function (k, e) {
      //     if ($(e).attr('contenteditable')) { $(e).attr('contenteditable', 'true'); }
      //     $(e).removeAttr('disabled');
      //   });
      // }
    }
    // disable all input, also check themes
    format_visual_forms();


    function add_ui_pos(e) {
      ui_pos(e, function (coll) {
        coll.push([$(e).attr('id'), e.nodeName == 'stop' ? 'after' : 'at']);
        return coll;
      });
    }

    function del_ui_pos(e) {
      ui_pos(e, function (coll) {
        coll.splice(coll.findIndex((ele) => ele[0] == $(e).attr('id')), 1);
        return coll;
      });
    }


    function ui_pos(e, bl) {
      var url = $("body").attr("current-instance");
      var coll = [];
      $(
        "g.element.primitive > g.activities.active, g.element.primitive > g.activities.passive"
      ).each(function (a, b) {
        coll.push([
          $(b).parent().attr("element-id"),
          $(b).parent().attr("element-type") == "stop" ? "after" : "at",
        ]);
      });
      coll = bl(coll);
      var vals = "";
      $(coll).each(function (k, ele) {
        vals += "<" + ele[0] + ">" + ele[1] + "</" + ele[0] + ">";
      });
      console.log("Saving positions:", vals, JSON.stringify(vals));
      vals =
        "<positions xmlns='http://cpee.org/ns/properties/2.0'>" +
        vals +
        "</positions>";
      // $.ajax({
      //   type: "PUT",
      //   url: url + "/properties/positions/",
      //   contentType: "application/xml",
      //   headers: {
      //     "Content-ID": "positions",
      //     "CPEE-Event-Source": myid,
      //   },
      //   data: vals,
      //   success: monitor_instance_pos,
      //   error: report_failure,
      // });
    }


    function monitor_instance_pos() {

      if (graph_position && graph_position == "false") {
        save["instance_pos"] = [];
        format_visual_clear();
        format_instance_pos();
        return;
      }
      var url = $("body").attr("current-instance");
      $.ajax({
        type: "GET",
        url: url + "/properties/positions/",
        success: function (res) {
          save["instance_pos"] = $("positions > *", res);
          format_visual_clear();
          format_instance_pos();
        },
      });
    }

    function report_failure() { }


    function save_testsetfile() {
      console.log("Saving test set file...", activeModel.data);
      // var def = new $.Deferred();
      // def.done(function (name, testset) {
      //   var ct = new Date();
      //   $('#savetestsetfile').attr('download', name + '.xml');
      //   $('#savetestsetfile').attr('href', 'data:application/xml;charset=utf-8;base64,' + $B64(testset.serializePrettyXML()));
      //   document.getElementById('savetestsetfile').click();
      // });
      // get_testset(def);
    }

    function get_testset(deferred) {
      var url = $('body').attr('current-instance');

      $.ajax({
        type: "GET",
        url: url + "/properties/",
        success: function (res) {
          var testset = $X('<testset xmlns="http://cpee.org/ns/properties/2.0"/>');
          testset.append($(res.documentElement).children());
          $('testset > state', testset).remove();
          $('testset > status', testset).remove();
          $('testset > positions', testset).remove();
          $('testset > dsl', testset).remove();
          $('testset > description > *', testset).remove();
          $('testset > description', testset).append($('testset > dslx', testset).children());
          $('testset > transformation', testset).remove();
          $('testset > dsl', testset).remove();
          $('testset > dslx', testset).remove();
          $('testset > attributes > uuid', testset).remove();
          testset.append($X('<transformation xmlns="http://cpee.org/ns/properties/2.0"><description type="copy"/><dataelements type="none"/><endpoints type="none"/></transformation>'));
          var name = $('testset > attributes > info', testset).text();
          $('[xmlns]', testset).each((idx, ele) => {
            if (ele.parentNode.namespaceURI == ele.getAttribute('xmlns')) {
              ele.removeAttribute('xmlns');
            }
          });

          // $.ajax({
          //   type: "GET",
          //   url: url + "/notifications/subscriptions/",
          //   success: async function (res) {
          //     let values = $("subscriptions > subscription[url]", res);
          //     let subs = $X('<subscriptions xmlns="http://riddl.org/ns/common-patterns/notifications-producer/2.0"/>');
          //     let promises = [];
          //     let scount = 0;
          //     values.each(function () {
          //       let sid = $(this).attr('id');
          //       if (sid.match(/^_/)) {
          //         scount += 1;
          //         promises.push(
          //           $.ajax({
          //             type: "GET",
          //             url: url + "/notifications/subscriptions/" + sid,
          //             error: report_failure
          //           }).then(function (a) {
          //             subs.append($(a.documentElement));
          //           })
          //         );
          //       };
          //     });
          //     await Promise.all(promises);
          //     if (scount > 0) { testset.append(subs); }
          //     deferred.resolve(name, testset);
          //   },
          //   error: function () { deferred.reject(); report_failure(); }
          // });

        },
        error: function (e) {
          deferred.reject();
          report_failure();
          console.error("Error fetching test set:", e);
        }
      });
    }


    // #endregion
    const connectDB = () => {
      return new Promise((resolve, reject) => {
        const dbReq = indexedDB.open("MyDB", 1);
        dbReq.onupgradeneeded = function (event) {
          const db = event.target.result;
          // db.deleteObjectStore("models");
          // db.deleteObjectStore("documents");
          // db.deleteObjectStore("traces");
          if (!db.objectStoreNames.contains("documents")) {
            db.createObjectStore("documents", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("models")) {
            db.createObjectStore("models", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("traces")) {
            const traceStore = db.createObjectStore("traces", {
              keyPath: "id",
              autoIncrement: true,
            });
            traceStore.createIndex("document_id", "document_id", { unique: false });
            traceStore.createIndex("model_id", "model_id", { unique: false });
          }

        };

        dbReq.onsuccess = function (event) {
          db = event.target.result;
          resolve(db);
        };
        dbReq.onerror = function (event) {
          console.error('Database error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    };
    const deleteDocument = async (docId) => {
      await deleteDocumentCascadeById(db, docId);
      const docTraces = getDocumentTraces(docId);
      docTraces.forEach(trace => {
        const modelIndex = models.findIndex(m => m.id == trace.model_id);
        if (modelIndex !== -1) {
          models.splice(modelIndex, 1);
        }
        const $modelDiv = $modelsArea.find(`div[data-modelid='${trace.model_id}']`);
        $modelDiv.remove();
      });
      if (activeDocId == docId) {
        clearOverlayLayers();
        $documentContent.empty();
        activeDocId = null;
        $generateButton.prop('disabled', true);

      }
      if (getActiveModelDocumentId() == docId) {
        setActiveModel(null);
      }
      deleteDocumentTraces(docId);

    };
    const renderDocumentItem = async (doc) => {
      const $li = $("<li>");
      $li.attr("data-docid", String(doc.id));
      $li.on("click", onDocumentSelect);
      $span = $('<span>').text(doc.name);
      const deleteDocButton = $('<button>').text('Delete').on('click', async (event) => {
        event.stopPropagation();
        await deleteDocument(doc.id);
        $li.remove();
        // if (activeDocId === doc.id) {
        //   $documentContent.empty();
        //   activeDocId = null;
        //   $generateButton.prop('disabled', true);
        // }
      });
      $li.append($span);
      $li.append(deleteDocButton);
      $li.attr("data-docid", String(doc.id));
      $li.on("click", onDocumentSelect);
      $documentList.append($li);
    };
    const loadDocumentList = async () => {
      documentList = await getDocumentList(db);
      documentList.forEach(doc => {
        renderDocumentItem(doc);
        // const $option = $("<option>").val(doc.id).text(doc.name);
        // $('#documentListSelect').append($option);
      });
    };

    const loadTraces = async () => {
      for (const doc of documentList) {
        const newTraces = await getTracesByDocumentId(db, doc.id);
        traces = [...traces, ...newTraces];
      }
    };

    const loadModels = async () => {
      for (const trace of traces) {
        const model = await getModelById(db, trace.model_id);
        models.push(model);
        await renderModelInList(model);
      }
    };

    // #region Selection Range Serialization and Deserialization
    function getXPath(node, root = document.getElementById("documentContent")) {
      if (node === root) return '/';
      const path = [];
      let cur = node;
      while (cur && cur !== root) {
        const idx = Array.prototype.indexOf.call(cur.parentNode.childNodes, cur);
        path.unshift(idx);
        cur = cur.parentNode;
      }
      return '/' + path.join('/');
    }

    function getNodeByXPath(path, root = document.getElementById("documentContent")) {
      const parts = path.split('/').filter(Boolean);
      let node = root;
      for (const idx of parts) {
        const i = parseInt(idx, 10);
        if (!node || !node.childNodes[i]) return null;
        node = node.childNodes[i];
      }
      return node;
    }

    const serializeRange = (range) => {
      return {
        id: range.id,
        // color: h.color,
        startXPath: getXPath(range.startContainer),
        startOffset: range.startOffset,
        endXPath: getXPath(range.endContainer),
        endOffset: range.endOffset,
      };
    };

    const deserializeRange = (serializedRange) => {
      const startNode = getNodeByXPath(serializedRange.startXPath);
      const endNode = getNodeByXPath(serializedRange.endXPath);
      const range = document.createRange();
      range.setStart(startNode, serializedRange.startOffset);
      range.setEnd(endNode, serializedRange.endOffset);
      range.id = serializedRange.id;
      return range;
    };

    // #endregion

    // #region Render Selections Layer and Traces Layer
    const onRangeSelect = (event) => {
      event.stopPropagation();
      const $target = $(event.currentTarget).parent();
      $target.addClass("selected");
      const rangeId = $target.attr('id');
      $target.siblings().removeClass('selected');

      const rangeBoundingRect = $target[0].getBoundingClientRect();

      $document.one('mousedown', () => {
        $deleteSelectionButton.hide();
        $target.removeClass('selected');
      });

      $deleteSelectionButton.show().css({
        top: `${rangeBoundingRect.top + window.scrollY - 12}px`,
        left: `${rangeBoundingRect.right + window.scrollX - 12}px`,
      }).on('click', () => {
        // Remove range from highlightSelections and temporarySelections
        highlightSelections = highlightSelections.filter(r => r.id !== rangeId);
        temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
        // Remove the highlight from the UI
        $target.remove();
        $deleteSelectionButton.hide();
      });
    };


    const renderSelection = (range, modelId) => {
      const rangeId = range.id || Date.now();

      const $selectionDiv = $('<div>')
        .attr('id', rangeId)
        .attr('data-modelid', modelId || '')
        .addClass(`selection-wrapper ${modelId == getActiveModelId() ? 'active' : ''}`)
        .css({
          top: `${range.getBoundingClientRect().top + window.scrollY}px`,
          left: `${range.getBoundingClientRect().left + window.scrollX}px`,
          width: `${range.getBoundingClientRect().width}px`,
          height: `${range.getBoundingClientRect().height}px`,
        });
      const $rangeRect = $('<div>').addClass('range-rect');
      const rects = range.getClientRects();
      for (const rect of rects) {
        const $rectDiv = $rangeRect.clone();
        $rectDiv.css({
          top: `${rect.top + window.scrollY}px`,
          left: `${rect.left + window.scrollX}px`,
          width: `${rect.width}px`,
          height: `${rect.height}px`,
        }).on('click', onRangeSelect);
        $selectionDiv.append($rectDiv);
      }

      if (modelId) {
        const lastIndex = rects.length - 1;
        const lastRect = rects[lastIndex];

        const modelName = models.find(m => m.id == modelId)?.name || `Model ${modelId}`;
        const labelSpan = $('<span>').attr('data-modelid', modelId).addClass('label-span').text(`${modelName}`).css({
          top: `${lastRect.top + window.scrollY - 10}px`,
          left: `${lastRect.right + window.scrollX}px`,
        }).on('click', (event) => {
          event.stopPropagation();
          setActiveModel(modelId);
        });
        $selectionDiv.append(labelSpan);
        $tracesLayer.append($selectionDiv);
      } else {
        $temporarySelectionsLayer.append($selectionDiv);
      }

    };
    const clearOverlayLayers = () => {
      clearTraceLayer();
      clearTemporarySelections();

    };
    const clearTraceLayer = () => {
      $tracesLayer.empty();
    };
    const clearTemporarySelections = () => {
      if (temporarySelections.length > 0) {
        temporarySelections = [];
        $temporarySelectionsLayer.empty();

      };
    }

    const rerenderTemporarySelectionsLayer = () => {
      if (temporarySelections.length > 0) {
        $temporarySelectionsLayer.empty();
        temporarySelections.forEach(range => renderSelection(range));
      }
    };
    const renderTrace = ({ selections: selections, model_id: modelId }) => {
      selections.forEach(serializedRange => {
        const range = deserializeRange(serializedRange);
        renderSelection(range, modelId);
      });
    };

    const rerenderTracesLayer = () => {
      clearTraceLayer();
      if (activeDocId) {
        const docTraces = traces.filter(trace => trace.document_id == activeDocId);
        if (docTraces.length) {
          docTraces.forEach(trace => renderTrace(trace));
        }
      }
    };
    const rerenderOverlayLayers = () => {
      rerenderTracesLayer();
      rerenderTemporarySelectionsLayer();
    };
    // #endregion



    const setActiveDocument = async (docId) => {
      if (docId && docId != activeDocId) {
        const activeModelDocId = getActiveModelDocumentId();
        if (getActiveModelDocumentId() != docId) {
          setActiveModel(null);
        }
        activeDocId = docId;
        $documentList.children().each((index, element) => {
          const $element = $(element);
          if ($element.data('docid') === docId) {
            $element.addClass("active");
          } else {
            $element.removeClass("active");
          }
        });
        await loadDocument(docId);
        clearTemporarySelections();
        rerenderTracesLayer();
      }
    };

    const setActiveModel = async (modelId) => {

      console.log('001-Setting active model to ID:', modelId);
      if (modelId && modelId != (activeModel && activeModel.id)) {
        console.log('001-Setting active model to ID:', modelId);
        activeModel = await getModelById(db, modelId);
        showModel(activeModel);
        $('.model-container').removeClass('active');
        $(`.model-container[data-modelid="${modelId}"]`).addClass('active');

        const documentId = getActiveModelDocumentId();
        await setActiveDocument(documentId);

        $('.selection-wrapper').removeClass("active");
        $(`.selection-wrapper[data-modelid="${modelId}"]`).addClass("active");

      } else if (!modelId) {
        activeModel = null;
        $('.model-container').removeClass('active');
        $('.selection-wrapper').removeClass("active");


        $('#activeModelName').text("");
        // console.log('Clearing active model canvas');
        $('#activeModelCanvas').empty();
      }

    };

    const onDocumentSelect = async (event) => {
      event.stopPropagation();
      const docId = $(event.currentTarget).data('docid');
      setActiveDocument(docId);
    };


    const loadDocument = async (docId) => {
      const content = await getDocumentContentById(db, docId);
      const htmlContent = new DOMParser().parseFromString(content, "text/html").body.innerHTML;
      $documentContent.html(htmlContent || '');
    };

    async function getFileContentInHTML(file) {
      let fileContent = "";
      if (file.type === "application/pdf") {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let pdfText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          fileContent += content.items.map(item => item.str).join(" ") + "\n";
        }
      }

      else if (
        file.type === "application/msword" ||
        file.name.endsWith(".doc") ||
        file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
        file.name.endsWith(".docx")
      ) {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        fileContent = new DOMParser().parseFromString(result.value, "text/html").body.innerHTML;
      }
      else {
        fileContent = await file.text();
      }
      return fileContent;
    }

    const showModel = (model) => {
      // const { name: modelName, data: modelData } = model;
      $('#activeModelName').text(model.name);
      // console.log('Showing model:', model);
      var parser = new DOMParser();
      let data = parser.parseFromString(model.data, "application/xml");
      if (data.documentElement.nodeName != 'description') {
        data = $('description', data)[0];
      } else {
        data = data.documentElement;
      }
      model.data = data
      console.log('Parsed model data for visualization:', data);
      save['graph_theme'] = 'preset_copy';
      save['graph_adaptor'] = new WfAdaptor('themes/preset_copy/theme.js', function (graphrealization) {
        // graphrealization.draw_labels = (max, labels, dimensions, striped) => {
        //   draw_extended_columns(graphrealization, max, labels, dimensions, striped)
        // };
        graphrealization.set_svg_container($('#activeModelCanvas'));
        graphrealization.set_label_container($('#activeModelGrid'));
        graphrealization.set_description($(data), true);
      });
    };



    const renderModelInList = async ({ id: modelId, name: modelName, content: modelContent, svg: svgContent }) => {
      var gridId = `modelGrid_${modelId}`;
      var canvasId = `modelCanvas_${modelId}`;
      const $modelsArea = $("#models");
      const $modelContainer = $("<div>").addClass("model-container").attr("data-modelid", modelId);
      $modelContainer.text(`${modelName}`);

      $modelsArea.append($modelContainer);
      const $gridDiv = $("<div>").attr("id", gridId);

      const svgData = new DOMParser().parseFromString(svgContent, "image/svg+xml").documentElement;
      $gridDiv.append(svgData);
      $gridDiv.append(svgData);
      $modelContainer.append($gridDiv);
      $modelContainer.on("click", (event) => {
        event.stopPropagation();
        setActiveModel(modelId);
      });
    };

    const createSampleModel = async () => {

      // choose a random XML from the "templates" folder and return its text

      const templatesFolder = 'templates/';

      async function fetchTemplatesList() {
        try {
          const r = await fetch(`${templatesFolder}templates.json`);
          if (r.ok) {
            const arr = await r.json();
            return arr.map(f => `${f.name}.xml`);
          }
        } catch (e) {
          console.error('Error fetching .templates.json:', e);
        }
      }

      try {
        const list = await fetchTemplatesList();
        // const list = [];
        if (!list || !list.length) {
          throw new Error('No templates found in templates.json');
        }
        const chosen = list[Math.floor(Math.random() * list.length)];
        const resp = await fetch(`${templatesFolder}${chosen}`);
        console.log('Fetched template:', chosen);
        if (!resp.ok) {
          throw new Error(`Failed to fetch template ${chosen}, status ${resp.status}`);
        }
        return await resp.text();
      } catch (err) {
        console.error('createSampleModel error:', err);
        // final fallback
        const resp = await fetch('sample_model_with_subprocess.xml');
        // const resp = await fetch('sample_model.xml');
        if (!resp.ok) throw err;
        return await resp.text();
      }

    };
    const generateModelLLM = async (inputText) => {
      // Placeholder for LLM integration
      // In a real implementation, this would call an API to generate a model based on inputText
      console.log('Generating model using LLM for input text:', inputText);
      // For now, just return a sample model

      const xml = "<description xmlns=\"http://cpee.org/ns/description/1.0\"/>"

      const fd = new FormData();
      fd.append("rpst_xml", new Blob([xml], { type: "text/xml" }));
      fd.append("user_input", new Blob([inputText], { type: "text/plain" }));
      fd.append("llm", new Blob(["gemini-2.0-flash"], { type: "text/plain" }));

      const llmResponse = $.ajax({
        url: "https://autobpmn.ai/llm/",
        method: "POST",
        data: fd,
        contentType: false,
        processData: false,
        xhrFields: { withCredentials: true },
        crossDomain: true,
        success: (data) => {
          console.log('LLM generation request sent successfully', data);
          return data;
        },
        error: (xhr) => {
          console.log("LLM generation request failed", xhr.status, xhr.responseText);
          throw new Error(`LLM request failed: ${xhr.status}`);
        }
      });

      return llmResponse;


      // return new Promise((resolve, reject) => {
      //   $.ajax({
      //     url: "https://autobpmn.ai/llm/",
      //     method: "POST",
      //     data: fd,
      //     contentType: false,
      //     processData: false,
      //     xhrFields: { withCredentials: true },
      //     crossDomain: true,
      //     success: (data) => {
      //       console.log('LLM generation request sent successfully', data);
      //       resolve(data);
      //     },
      //     error: (xhr) => {
      //       console.log("LLM generation request failed", xhr.status, xhr.responseText);
      //       reject(new Error(`LLM request failed: ${xhr.status}`));
      //     }
      //   });
      // });


      // return await createSampleModel();
    };
    const generateModel = async () => {

      const selectedText = temporarySelections.map(range => range.toString()).join(' ');
      // generatedModel = await createSampleModel();

      generateModelLLM(selectedText);
      let generatedModel;
      try {
        const res = await generateModelLLM(selectedText);
        if (typeof res === 'string') {
          generatedModel = res;
        } else if (res && res.rpst_xml) {
          generatedModel = (typeof res.rpst_xml === 'string') ? res.rpst_xml : new XMLSerializer().serializeToString(res.rpst_xml);
        } else if (res && res.xml) {
          generatedModel = (typeof res.xml === 'string') ? res.xml : new XMLSerializer().serializeToString(res.xml);
        } else if (res && res.description) {
          generatedModel = (typeof res.description === 'string') ? res.description : new XMLSerializer().serializeToString(res.description);
        } else {
          generatedModel = '<description xmlns="http://cpee.org/ns/description/1.0"/>';
        }
      } catch (err) {
        console.log('001 Error generating model:', err);
        const rejectMessage = err?.message ?? err?.responseText ?? (typeof err === 'string' ? err : JSON.stringify(err));
        console.log('002 Reject message:', rejectMessage);

        $generateButton.prop('disabled', false);
        // return;
      }
      console.log('003 Next step -  Generated Model :', generatedModel);
      activeModel = {
        data: generatedModel,
      };
      showModel(activeModel);
      $generateButton.prop("disabled", false);
      $("#generatedModelActionBar").css("visibility", "visible");
    };

    const regenerateModel = async () => {
      const selectedText = temporarySelections.map(range => range.toString()).join(' ');
      generatedModel = await createSampleModel();
      activeModel = {
        ...activeModel,
        data: generatedModel,
      };
      showModel(activeModel);
      $generateButton.prop("disabled", false);
      $regenerateButton.prop("disabled", false);
      $("#generatedModelActionBar").css("visibility", "visible");
    };

    /*const deleteRangeById = (rangeId) => {
      highlightSelections = highlightSelections.filter(r => r.id !== rangeId);
      temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
      $temporarySelectionsLayer.find(`#${rangeId}`).remove();
    };
 
    const clearRangeSelection = () => {
      $deleteSelectionButton.hide();
      $temporarySelectionsLayer.find('.selection-wrapper.active').removeClass('active');
    };*/



    // const getXPath = (node, root = document.getElementById("documentContent")) => {
    //   // const paths = [];
    //   // for (; node && node !== root; node = node.parentNode) {
    //   //   let index = 0;
    //   //   let sibling = node.previousSibling;
    //   //   while (sibling) {
    //   //     if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === node.nodeName) {
    //   //       index++;
    //   //     }
    //   //     sibling = sibling.previousSibling;
    //   //   }
    //   //   const tagName = node.nodeType === Node.ELEMENT_NODE ? node.nodeName : 'text()';
    //   //   const pathIndex = index ? `[${index + 1}]` : '';
    //   //   paths.unshift(`${tagName}${pathIndex}`);
    //   // }
    //   // return paths.length ? '/' + paths.join('/') : null;

    //   const path = [];
    //   while (node && node !== root) {
    //     const index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
    //     path.unshift(index);
    //     node = node.parentNode;

    //     return '/' + path.join('/');
    //   }
    // };

    // const getNodeByXPath = (path, root = document.getElementById("documentContent")) => {
    //   // const parts = path.split('/').filter(Boolean);
    //   // let node = root;
    //   // for (const part of parts) {
    //   //   let tagName = part;
    //   //   let index = 0;
    //   //   const match = part.match(/(.*)\[(\d+)\]$/);
    //   //   if (match) {
    //   //     tagName = match[1];
    //   //     index = parseInt(match[2], 10) - 1;
    //   //   }
    //   //   let count = -1;
    //   //   let found = false;
    //   //   for (const child of node.childNodes) {
    //   //     if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === tagName) {
    //   //       count++;
    //   //       if (count === index) {
    //   //         node = child;
    //   //         found = true;
    //   //         break;
    //   //       }
    //   //     }
    //   //   }
    //   //   return found ? node : null;
    //   // };
    //   const parts = path.split('/').filter(Boolean);
    //   let node = root;
    //   for (const idx of parts) {
    //     const i = parseInt(idx, 10);
    //     if (!node || !node.childNodes[i]) return null;
    //     node = node.childNodes[i];
    //   }
    //   return node;
    // };


    const handleTextSelection = () => {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      if (range.collapsed) return;
      // if (!content.contains(range.commonAncestorContainer)) return;
      $generateButton.prop("disabled", false);
      if (activeModel && activeModel.id) {
        // $generateButton.hide();
        $generateButton.text("Generate New Model");
        $regenerateButton.show();
      } else {
        // $generateButton.show();
        $generateButton.text("Generate Model");
      }
      const clonedRange = range.cloneRange();
      clonedRange.id = Date.now();
      temporarySelections.push(clonedRange);
      renderSelection(range);
      selection.removeAllRanges();
    };




    //#region CPEE Code
    function do_main_save() {
      console.log('Auto-saving details changes...!!!');
      if (save['details'].has_changed()) {
        do_main_work(save['details_target'].svgid);
      }
    }

    function do_main_work(svgid) {
      var desc = save['details_target'].model;
      var node = desc.get_node_by_svg_id(svgid);
      var orignode = save['graph_adaptor'].illustrator.get_node_by_svg_id(svgid).parents('g.element[element-id]');
      var origtype = orignode.attr('element-type') + '_' + orignode.attr('element-endpoint');

      var url = $('body').attr('current-instance');

      var nnew;
      if (svgid != save['details_target'].svgid) {
        let tn = desc.get_node_by_svg_id(svgid).get(0);
        let rng = desc.elements[$(tn).attr('svg-subtype')].clone();
        if (save['endpoints_cache'][$(tn).attr('endpoint')] && save['endpoints_cache'][$(tn).attr('endpoint')].schema) {
          let schema = save['endpoints_cache'][$(tn).attr('endpoint')].schema.documentElement;
          $(rng).find(' > element[name="parameters"] > element[name="arguments"]').replaceWith($(schema).clone());
        }
        if (save['endpoints_list'][$(tn).attr('endpoint')] && (!save['endpoints_list'][$(tn).attr('endpoint')].startsWith('http') || save['endpoints_list'][$(tn).attr('endpoint')].match(/^https?-/))) {
          $(rng).find(' > element[name="parameters"] > element[name="method"]').remove();
        }
        let rngw = new RelaxNGui(rng, $('#relaxngworker'), desc.context_eval);
        nnew = $(rngw.save().documentElement);
      } else {
        save['details'].set_checkpoint();
        nnew = $(save['details'].save().documentElement);
      }
      nnew.attr('svg-id', svgid);

      if ($('*[svg-id]', node).length > 0) {
        nnew.append(node.children().filter(function () { return this.attributes['svg-id'] != undefined; }));
      }

      if (node[0].namespaceURI == nnew.attr('xmlns')) { // remove xmlns when it is the same as in the parent node
        nnew[0].removeAttribute('xmlns');
      }

      // copy all elements from different namespaces
      [...node[0].attributes].forEach(attr => {
        if (attr && attr.namespaceURI && attr.namespaceURI != 'http://cpee.org/ns/description/1.0') {
          nnew[0].setAttributeNS(attr.namespaceURI, attr.nodeName, attr.nodeValue);
        }
      });

      node.replaceWith(nnew);

      var ttarget = manifestation.adaptor.illustrator.get_node_by_svg_id(svgid);
      var tnewnode = ttarget.parents('g.element[element-id]');
      var tnewtype = tnewnode.attr('element-type') + '_' + tnewnode.attr('element-endpoint');

      desc.refresh(function (graphrealization) {
        var vtarget = manifestation.adaptor.illustrator.get_node_by_svg_id(svgid);
        if (vtarget.length > 0) {
          vtarget.parents('g.element[element-id]').addClass('selected');
        }
        manifestation.adaptor.illustrator.get_label_by_svg_id(svgid).addClass('selected');
        $('#graphgrid [element-id=' + svgid + ']').addClass('selected');


        var newnode = vtarget.parents('g.element[element-id]');
        var newtype = newnode.attr('element-type') + '_' + newnode.attr('element-endpoint');
        var g = graphrealization.get_description();
        console.log('Auto-save graph diff????', g);
        save['graph'] = $X(g);
        save['graph'].removeAttr('svg-id');
        save['graph'].removeAttr('svg-type');
        save['graph'].removeAttr('svg-subtype');
        save['graph'].removeAttr('svg-label');

        if (newtype != origtype) {
          manifestation.update_details(svgid);
          do_main_work(svgid);
        } else {
          console.log('Auto-save triggered???????', desc.get_description());
          // $.ajax({
          //   type: "PUT",
          //   url: url + "/properties/description/",
          //   contentType: 'text/xml',
          //   headers: {
          //     'Content-ID': 'description',
          //     'CPEE-Event-Source': myid
          //   },
          //   data: desc.get_description()
          // });
          format_instance_pos();

          document.dispatchEvent(graph_changed);

          ////////////////////////////
          // holy shit, f***in papercut. When blur/focusout from within relaxngui,
          // click on original target after graph was updated. tsvgid has to be
          // saved in mousedown because blur/focusout is between mousedown and click.
          ////////////////////////////
          if (save['details_target'].svgid != save['details_target'].tsvgid) {
            manifestation.adaptor.illustrator.get_label_by_svg_id(save['details_target'].tsvgid).trigger('click');
          }
        }

      });
    }
    // #endregion

    $document.ready(async () => {
      await connectDB();
      await loadDocumentList();
      await loadTraces();
      await loadModels();

      if (documentList.length) {
        setActiveDocument(documentList[documentList.length - 1]?.id);
      }
      // generateModel();

      var timer;



      $(document).on('input', '#dat_details input, #dat_details textarea, #dat_details [contenteditable]', function (e) {
        console.log('!!!Input detected, scheduling auto-save...');
        clearTimeout(timer);
        timer = setTimeout(do_main_save, 5000);
      });
      // only for contenteditable divs
      $(document).on('keypress', '#dat_details div[contenteditable]', function (e) {
        if (e.keyCode == 13) {
          document.execCommand('insertLineBreak')
          e.preventDefault()
        }
      });
      $(document).on('relaxngui_remove', '#dat_details', function (e) {
        clearTimeout(timer);
        do_main_save();
      });
      $(document).on('relaxngui_move', '#dat_details', function (e) {
        clearTimeout(timer);
        do_main_save();
      });
      $(document).on('relaxngui_change', '#dat_details', function (e) {
        clearTimeout(timer);
        do_main_save();
      });


    });

    $documentsInput.on("change", async (event) => {
      for (const file of event.target.files) {
        if (!file) continue;
        const content = await getFileContentInHTML(file);
        // Store document in IndexedDB
        const documentId = await createDocument(db, file.name, content);
        // const $ul = $("#documentList");
        // const $li = $("<li>").text(file.name);
        // $li.attr("data-docid", String(documentId));
        // $li.on("click", onDocumentSelect);
        renderDocumentItem({ id: documentId, name: file.name });
        // $ul.append($li);
        setActiveDocument(documentId);
      }
    });
    $documentContent.on("mouseup", handleTextSelection);
    $documentContent.on("scroll", rerenderOverlayLayers);
    $(window).on("resize", rerenderOverlayLayers);

    $generateButton.on("click", async () => {
      $generateButton.prop("disabled", true);
      generateModel();
    });
    $regenerateButton.on("click", async () => {
      $generateButton.prop("disabled", true);
      $regenerateButton.prop("disabled", true);
      regenerateModel();
    });
    $keepButton.on("click", async () => {
      let modelId = getActiveModelId();
      let model

      if (!modelId) {
        const svgContent = $('#activeModelCanvas');
        const $svgCopy = svgContent.clone(false);
        $svgCopy.removeAttr('id');
        const svg = $svgCopy.prop('outerHTML');
        activeModel.svg = svg;
        activeModel.data = new XMLSerializer().serializeToString(activeModel.data);
        modelId = await createModel(db, activeModel);
        model = await updateModel(db, modelId, { name: `Model_${modelId}` });
        renderModelInList(model);
      } else {
        // model = await updateModel(db, modelId, activeModel);
        await saveModel();
      }
      models.push(model);
      setActiveModel(null);
      var trace = {
        document_id: activeDocId,
        model_id: modelId,
        selections: temporarySelections.map(range => serializeRange(range)),
      };

      await createTrace(db, trace);
      traces.push(trace);
      renderTrace(trace);
      clearTemporarySelections();
      $generateButton.prop("disabled", true);
      $("#generatedModelActionBar").css("visibility", "hidden");

    });

    $cancelButton.on("click", () => {
      activeModel = null;
      $("#activeModelName").text("");
      $("#activeModelCanvas").empty();
      $("#generatedModelActionBar").css("visibility", "hidden");
    });

    $("button[name=savetestsetfile]").click(function () { save_testsetfile(); });

    // const refreshModelList = async () => {
    //   $modelsArea.empty();
    //   for (const model of models) {
    //     await renderModelInList(model);
    //   }
    // };

    const saveModel = async (e) => {
      // console.log('Saving model...');
      // console.log("Saving model file...", activeModel.data);
      const svgContent = $('#activeModelCanvas');
      const $svgCopy = svgContent.clone(false);
      $svgCopy.removeAttr('id');
      const svg = $svgCopy.prop('outerHTML');
      activeModel.svg = svg;
      // activeModel.data = new XMLSerializer().serializeToString(activeModel.data);
      // const updatedModel = { ...activeModel, data: new XMLSerializer().serializeToString(activeModel.data) };
      // updateModel(db, activeModel.id, );
      const updatedModel = await updateModel(db, activeModel.id, { svg: svg, data: new XMLSerializer().serializeToString(activeModel.data) });
      const idx = models.findIndex(m => m.id === updatedModel.id);
      if (idx !== -1) {
        models[idx] = updatedModel;

        const $container = $(`.model-container[data-modelid="${updatedModel.id}"]`);
        if ($container.length) {
          // Rebuild container contents
          $container.empty().text(updatedModel.name);

          const $gridDiv = $("<div>").attr("id", `modelGrid_${updatedModel.id}`);
          try {
            const svgDoc = new DOMParser().parseFromString(updatedModel.svg || '', "image/svg+xml").documentElement;
            if (svgDoc) $gridDiv.append(svgDoc);
          } catch (err) {
            console.warn('Failed to parse updated model SVG:', err);
          }
          $container.append($gridDiv);

          // Reattach click handler
          $container.off('click').on('click', (e) => { e.stopPropagation(); setActiveModel(updatedModel.id); });
        }
      } else {
        models.push(updatedModel);
        renderModelInList(updatedModel);
      }
    };
    $("button[name=savemodelfile]").click(function (e) { saveModel(e); });  
  </script>
</body>
</html>