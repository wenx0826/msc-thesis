<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Document-Based Process Modeller</title>
  <!-- libs, do not modify. When local than load local libs. -->
  <script type="text/javascript" src="js_libs/jquery.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.browser.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svg.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svgdom.min.js"></script>
  <script type="text/javascript" src="js_libs/vkbeautify.js"></script>
  <script type="text/javascript" src="js_libs/util.js"></script>
  <script type="text/javascript" src="js_libs/printf.js"></script>
  <script type="text/javascript" src="js_libs/strftime.min.js"></script>
  <script type="text/javascript" src="js_libs/parsequery.js"></script>
  <script type="text/javascript" src="js_libs/underscore.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.caret.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.cookie.js"></script>
  <script type="text/javascript" src="js_libs/marked.min.js"></script>

  <script type="text/javascript" src="js_libs/relaxngui.js"></script>

  <script type="text/javascript" src="js_libs/uidash.js"></script>



  <!-- modelling ui -->
  <script type="text/javascript" src="js/wfadaptor.js"></script>
  <link rel="stylesheet" href="css/wfadaptor.css" type="text/css" />


  <link rel="stylesheet" href="js_libs/uidash.css" type="text/css">
  <link rel="stylesheet" href="js_libs/relaxngui.css" type="text/css">

  <!-- custom stuff, play arround  -->
  <link rel="stylesheet" href="css/ui.css" type="text/css">
  <link rel="stylesheet" href="css/globalui_cpee.css" type="text/css">

  <!-- Flos Stuff -->
  <script type="text/javascript" src="js/structured.js"></script>
  <style type="text/css">
    @font-face {
      font-family: TencentSans;
      src: url("chrome-extension://lkjkfecdnfjopaeaibboihfkmhdjmanm/static/fonts/TencentSans.woff2");
    }
  </style>

  <!-- my libs-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- my scripts - DB simulation -->
  <script src="js/db_documents.js"></script>
  <script src="js/db_models.js"></script>
  <script src="js/db_traces.js"></script>

  <!-- my ui-->
  <link rel="stylesheet" href="css/myui.css" type="text/css" />

</head>
<body data-defaultconfig="index.json" is="x-ui-" data-names="3">
  <ui-rest>
    <ui-content>
      <!-- Left: DocumentPanel -->
      <ui-rest style="flex:2;">
        <!-- Document List Pane -->
        <ui-tabbed>
          <ui-tabbar>
            <ui-tab class="switch"></ui-tab>
            <ui-tab class="" data-tab="documents" id="tabdocuments" style="flex: 1;">Documents</ui-tab>
          </ui-tabbar>
          <ui-content>
            <ui-area data-belongs-to-tab="documents" id="areadocuments">
              <ul id="documentList">
              </ul>
              <label for="documentsInput">Choose documents to upload</label>
              <input type="file" id="documentsInput" multiple />
            </ui-area>
          </ui-content>
        </ui-tabbed>
        <!-- Text Action Bar -->
        <!-- Document Viewer -->
        <ui-area id="highlightLayer"></ui-area>

        <ui-rest class="panel" style="margin:0.5em;">
          <ui-content>

            <ui-area id="documentContent">
              <p>第一段：这是一个虚拟高亮层的示例。高亮区域绘制在文字下方，不会修改原文 DOM。</p>
              <p>第二段：按住 Ctrl（或 Cmd）可以连续选择多段文字，每段会生成独立的高亮。</p>
              <p>第三段：滚动页面或调整窗口时，高亮会自动同步位置。</p>
              <p>第四段：点击高亮区域可删除该标记，导出功能可保存所有标记。</p>
              <p>第五段：这种技术常用于阅读器、批注系统、AI 文本分析工具中。</p>
            </ui-area>
          </ui-content>

          <div class="bottom-bar">
            <div class="button-group">

              <button id="generateButton" disabled>Generate</button>
            </div>
          </div>
        </ui-rest>
      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Middle: Current Model Panel -->
      <ui-rest class="panel" style="flex:2; margin: .5em 0;">
        <div id="activeModelName"></div>
        <ui-content>
          <div id='activeModelGrid'>
            <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink"
              id='activeModelCanvas' width='1' height='1'></svg>
          </div>
        </ui-content>
        <!-- Model Action Bar -->
        <div id="generatedModelActionBar" class="bottom-bar" style="visibility: hidden;">
          <div class="button-group">
            <button id="cancelButton">Cancel</button>
            <button id="keepButton">Keep</button>
          </div>
        </div>
      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Right: Models Panel-->
      <ui-rest style="flex:1; margin:0.5em; padding: .2em;" class="panel">
        <ui-tab>Models</ui-tab>
        <!-- <select id="documentListSelect">
          <option value="">-- Select a Document --</option>
        </select> -->
        <ui-rest>
          <ui-content>
            <ui-area id="models"></ui-area>
          </ui-content>

        </ui-rest>
        <!-- <div id='activeModelGrid'>
          <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink" id='activeModelCanvas'
            width='1' height='1'></svg>
        </div> -->
      </ui-rest>
    </ui-content>
  </ui-rest>
  <script>
    const $documentsInput = $('#documentsInput');
    const $documentList = $('#documentList');
    const $highlightLayer = $('#highlightLayer');
    const $documentContent = $('#documentContent');
    const $generateButton = $('#generateButton');

    const $keepButton = $('#keepButton');
    const $cancelButton = $('#cancelButton');

    let activeDocumentId = null;
    let selectedTextSegments = null;
    // let selectedModel = null;
    let activeModel = null;
    let documentList = [];
    let traceList = [];
    let modelList = [];

    let highlights = [];
    let db;

    const connectDB = () => {
      return new Promise((resolve, reject) => {
        const dbReq = indexedDB.open("MyDB", 1);
        dbReq.onupgradeneeded = function (event) {
          const db = event.target.result;
          // db.deleteObjectStore("models");
          // db.deleteObjectStore("documents");
          // db.deleteObjectStore("traces");
          if (!db.objectStoreNames.contains("documents")) {
            db.createObjectStore("documents", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("models")) {
            db.createObjectStore("models", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("traces")) {
            const traceStore = db.createObjectStore("traces", {
              keyPath: "id",
              autoIncrement: true,
            });
            traceStore.createIndex("document_id", "document_id", { unique: false });
            traceStore.createIndex("model_id", "model_id", { unique: false });
          }

        };

        dbReq.onsuccess = function (event) {
          db = event.target.result;
          resolve(db);
        };
        dbReq.onerror = function (event) {
          console.error('Database error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    };

    setActiveDocument = async (docId) => {
      if (docId !== activeDocumentId) {
        activeDocumentId = docId;
        $documentList.children().each((index, element) => {
          const $element = $(element);
          if ($element.data('docid') === docId) {
            $element.addClass("active");
          } else {
            $element.removeClass("active");
          }
        });
        const content = await getDocumentContentById(db, docId);
        const htmlContent = new DOMParser().parseFromString(content, "text/html").body.innerHTML;
        $documentContent.html(htmlContent || '');
      }
    };
    const onDocumentSelect = async (event) => {
      event.stopPropagation();
      const docId = $(event.currentTarget).data('docid');
      setActiveDocument(docId);
    };

    const onModelSelect = async (event) => {
      event.stopPropagation();
      var target = $(event.currentTarget);
      target.addClass("active");
      $('#models').children().not(target).removeClass('active');
      const modelId = target.data('modelid');

      if (modelId) {
        const model = await getModelById(db, modelId);
        setActiveModel(model);
      }

      const modelTrace = await getTraceByModelId(db, modelId);
      console.log('modelTrace', modelTrace);
      setActiveDocument(modelTrace.document_id);
    };

    const setActiveModel = (model) => {
      activeModel = model
      const { name: modelName, content: modelContent } = model;
      $('#activeModelName').text(modelName);

      var parser = new DOMParser();
      const data = parser.parseFromString(modelContent, "application/xml");
      new WfAdaptor('themes/default/theme.js', function (graphrealization) {
        graphrealization.draw_labels = (max, labels, shift, striped) => {
          // console.log(JSON.stringify(labels, null, "  "));
        };
        graphrealization.set_svg_container($('#activeModelCanvas'));
        graphrealization.set_label_container($('#activeModelGrid'));
        graphrealization.set_description($(data), true);
      });
    };

    const loadDocumentList = async () => {
      documentList = await getDocumentList(db);

      documentList.forEach(doc => {
        const $li = $("<li>").text(doc.name);
        $li.attr("data-docid", String(doc.id));
        $li.on("click", onDocumentSelect);
        $documentList.append($li);
      });
    };


    const renderModel = async ({ id: modelId, name: modelName, content: modelContent, svg: svgContent }) => {

      var gridId = `modelGrid_${modelId}`;
      var canvasId = `modelCanvas_${modelId}`;
      const $modelsArea = $("#models");
      const $modelContainer = $("<div>").addClass("model-container").attr("data-modelid", modelId);
      $modelContainer.text(`Model ${modelId}`);
      $modelsArea.append($modelContainer);
      const $gridDiv = $("<div>").attr("id", gridId);

      const svgData = new DOMParser().parseFromString(svgContent, "image/svg+xml").documentElement;
      $gridDiv.append(svgData);
      $gridDiv.append(svgData);
      $modelContainer.append($gridDiv);
      $modelContainer.on("click", onModelSelect);

    };
    const loadModels = async () => {
      documentList.forEach(async (doc) => {
        // console.log('Loading models for document', doc.id);
        const traces = await getTracesByDocumentId(db, doc.id);
        // console.log('traces for document', doc.id, traces);
        const modelIds = traces.map(trace => trace.modelId)
        traceList = [...traceList, ...traces];
        traces.forEach(async (trace) => {
          const model = await getModelById(db, trace.model_id);
          modelList.push(model);
          await renderModel(model);
        });
      });
      // const modelList = await getModelList(db);
      // console.log('Loaded models:', modelList);

    };

    $(document).ready(async () => {
      await connectDB();
      await loadDocumentList();
      await loadModels();
      $documentContent.on("mouseup", handleTextSelection);
      // highlightsScrollSync();
      // $documentContent.on("scroll", () => renderHighlights());
    });

    const deserializeRange = (serializedRange) => {
      const startNode = getNodeByXPath(serializedRange.startXPath);
      const endNode = getNodeByXPath(serializedRange.endXPath);
      const range = document.createRange();
      console.log("startNode:", startNode, "endNode:", endNode);

      range.setStart(startNode, serializedRange.startOffset);
      range.setEnd(endNode, serializedRange.endOffset);
      return range;
    };
    const renderSerializedRange = (serializedRange) => {
      const range = deserializeRange(serializedRange);
      renderHighlight(range);
    };

    const renderHighlight = (range) => {
      console.log("Adding highlight for range:", range);
      const $highlightLayer = $('#highlightLayer');
      const highlightId = `highlight_${Date.now()}`;
      const $highlightDiv = $('<div>')
        .addClass('highlight')
        .attr('id', highlightId)
        .css({
          position: 'absolute',
          backgroundColor: 'yellow',
          opacity: 0.5,
          pointerEvents: 'auto',
        })
        .on('click', function () {
          $(this).remove();
        });

      const rects = range.getClientRects();
      for (const rect of rects) {
        const $rectDiv = $highlightDiv.clone();
        $rectDiv.css({
          top: `${rect.top + window.scrollY}px`,
          left: `${rect.left + window.scrollX}px`,
          width: `${rect.width}px`,
          height: `${rect.height}px`,
        });
        $highlightLayer.append($rectDiv);
      }
    };

    // const renderHighlights = () => {
    //   $highlightLayer.empty();
    //   highlights.forEach((range) => {
    //     const rects = range.getClientRects();
    //     for (const rect of rects) {
    //       const $rectDiv = $('<div>')
    //         .addClass('highlight')
    //         .css({
    //           position: 'absolute',
    //           top: `${rect.top + window.scrollY}px`,
    //           left: `${rect.left + window.scrollX}px`,
    //           width: `${rect.width}px`,
    //           height: `${rect.height}px`,
    //           backgroundColor: 'yellow',
    //           opacity: 0.5,
    //           pointerEvents: 'auto',
    //         })
    //         .on('click', function () {
    //           $(this).remove();
    //         });
    //       $highlightLayer.append($rectDiv);
    //     }
    //   });
    // };



    $documentsInput.on("change", async (event) => {
      for (const file of event.target.files) {
        if (!file) continue;
        const content = await getFileContentInHTML(file);
        // Store document in IndexedDB
        const documentId = await createDocument(db, file.name, content);
        console.log('Stored document:', file.name, 'with id', documentId);
        const $ul = $("#documentList");
        const $li = $("<li>").text(file.name);
        $li.attr("data-docid", String(documentId));
        $li.on("click", onDocumentSelect);
        $ul.append($li);
      }
    });


    async function getFileContentInHTML(file) {
      let fileContent = "";
      if (file.type === "application/pdf") {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let pdfText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          fileContent += content.items.map(item => item.str).join(" ") + "\n";
        }
      }

      else if (
        file.type === "application/msword" ||
        file.name.endsWith(".doc") ||
        file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
        file.name.endsWith(".docx")
      ) {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        fileContent = new DOMParser().parseFromString(result.value, "text/html").body.innerHTML;
      }
      else {
        fileContent = await file.text();
      }
      return fileContent;
    }
    // const getXPath = (node, root = document.getElementById("documentContent")) => {
    //   // const paths = [];
    //   // for (; node && node !== root; node = node.parentNode) {
    //   //   let index = 0;
    //   //   let sibling = node.previousSibling;
    //   //   while (sibling) {
    //   //     if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === node.nodeName) {
    //   //       index++;
    //   //     }
    //   //     sibling = sibling.previousSibling;
    //   //   }
    //   //   const tagName = node.nodeType === Node.ELEMENT_NODE ? node.nodeName : 'text()';
    //   //   const pathIndex = index ? `[${index + 1}]` : '';
    //   //   paths.unshift(`${tagName}${pathIndex}`);
    //   // }
    //   // return paths.length ? '/' + paths.join('/') : null;

    //   const path = [];
    //   while (node && node !== root) {
    //     const index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
    //     path.unshift(index);
    //     node = node.parentNode;

    //     return '/' + path.join('/');
    //   }
    // };

    // const getNodeByXPath = (path, root = document.getElementById("documentContent")) => {
    //   // const parts = path.split('/').filter(Boolean);
    //   // let node = root;
    //   // for (const part of parts) {
    //   //   let tagName = part;
    //   //   let index = 0;
    //   //   const match = part.match(/(.*)\[(\d+)\]$/);
    //   //   if (match) {
    //   //     tagName = match[1];
    //   //     index = parseInt(match[2], 10) - 1;
    //   //   }
    //   //   let count = -1;
    //   //   let found = false;
    //   //   for (const child of node.childNodes) {
    //   //     if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === tagName) {
    //   //       count++;
    //   //       if (count === index) {
    //   //         node = child;
    //   //         found = true;
    //   //         break;
    //   //       }
    //   //     }
    //   //   }
    //   //   return found ? node : null;
    //   // };
    //   const parts = path.split('/').filter(Boolean);
    //   let node = root;
    //   for (const idx of parts) {
    //     const i = parseInt(idx, 10);
    //     if (!node || !node.childNodes[i]) return null;
    //     node = node.childNodes[i];
    //   }
    //   return node;
    // };


    function getXPath(node, root = document.getElementById("documentContent")) {
      if (node === root) return '/';
      const path = [];
      let cur = node;
      while (cur && cur !== root) {
        const idx = Array.prototype.indexOf.call(cur.parentNode.childNodes, cur);
        path.unshift(idx);
        cur = cur.parentNode;
      }
      return '/' + path.join('/');
    }

    /** 从 XPath 获取节点 */
    function getNodeByXPath(path, root = document.getElementById("documentContent")) {
      const parts = path.split('/').filter(Boolean);
      let node = root;
      for (const idx of parts) {
        const i = parseInt(idx, 10);
        if (!node || !node.childNodes[i]) return null;
        node = node.childNodes[i];
      }
      return node;
    }


    const serializeRange = (range) => {
      console.log("Serializing range:", range, "startOffset:", range.startOffset, "endOffset:", range.endOffset);
      return {
        // id: h.id,
        // color: h.color,
        startXPath: getXPath(range.startContainer),
        startOffset: range.startOffset,
        endXPath: getXPath(range.endContainer),
        endOffset: range.endOffset,
      };
    };
    const handleTextSelection = () => {

      const selection = window.getSelection();
      console.log("Selection:", selection);

      // console.log("selection.rangeCount", selection.rangeCount);
      // console.log("Selection text:", selection.toString());

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      if (range.collapsed) return;
      // if (!content.contains(range.commonAncestorContainer)) return;

      selectedText = selection.toString();

      $generateButton.prop("disabled", false);
      console.log("Range:", range);
      console.log("Range:", range.cloneRange);
      // highlights.push(range);
      // renderHighlight(range);
      const serializedRange = serializeRange(range);
      console.log("Serialized Range:", serializedRange);
      renderSerializedRange(serializedRange);

      sel.removeAllRanges();
      // if (selection && selection.rangeCount > 0) {
      //   console.log("Selection text:", selection.toString());
      //   const range = selection.getRangeAt(0); // Get the selected range
      //   const startOffset = range.startOffset; // Start position of the selection
      //   const endOffset = range.endOffset; // End position of the selection

      //   // Get the parent node's text content (assumes the selection is within the `p` tag)
      //   const parentNode = range.startContainer.parentNode;
      //   // if (parentNode && parentNode.tagName === "P") {
      //   //   const fullText = parentNode.textContent;
      //   //   // console.log("Full text:", fullText);
      //   //   // Split the text into before, selected, and after parts
      //   //   // beforeSelection.value = text.slice(0, startOffset);
      //   //   store.selectedText = text.slice(startOffset, endOffset);
      //   //   // afterSelection.value = text.slice(endOffset);
      //   // }
      // }

    };




    const createSampleModel = async () => {
      const resp = await fetch('Frames.xml');
      if (!resp.ok) {
        console.error('Failed to load Frames.xml:', resp.status, resp.statusText);
        return;
      }
      return await resp.text();
    };

    const generateModel = async () => {
      generatedModel = await createSampleModel();
      setActiveModel({ name: `Model_${modelList.length + 1}`, content: generatedModel });
      $("#generatedModelActionBar").css("visibility", "visible");
    };

    $generateButton.on("click", async () => {
      $generateButton.prop("disabled", true);
      generateModel();
    });

    $keepButton.on("click", async () => {

      const svgContent = $('#activeModelCanvas');
      const $svgCopy = svgContent.clone(false);
      $svgCopy.removeAttr('id');
      const svg = $svgCopy.prop('outerHTML');

      activeModel.svg = svg;
      const modelId = await createModel(db, activeModel);
      console.log('modelId', modelId);
      renderModel({ ...activeModel, id: modelId });
      await createTrace(db, {
        document_id: activeDocumentId,
        model_id: modelId,
        segments: selectedTextSegments,
      });

      $("#generatedModelActionBar").css("visibility", "hidden");

    });
    $cancelButton.on("click", () => {

      activeModel = null;
      $("#activeModelName").text("");
      console.log('Clearing active model canvas');
      $("#activeModelCanvas").empty();
      $("#generatedModelActionBar").css("visibility", "hidden");

      // if (selectedText) {
      //   generateButton.prop("disabled", true);
      //   $("#generatedModelActionBar").css("visibility", "visible");
      //   showSampleModel();
      //   // alert(`Generating model for selected text:\n${selectedText}`);
      // } else {
      //   alert("No text selected.");
      // }
    });

  </script>
</body>
</html>