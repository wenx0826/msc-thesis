<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Document-Based Process Modeller</title>
  <!-- libs, do not modify. When local than load local libs. -->
  <script type="text/javascript" src="js_libs/jquery.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.browser.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svg.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svgdom.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.caret.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.cookie.js"></script>
  <script type="text/javascript" src="js_libs/vkbeautify.js"></script>
  <script type="text/javascript" src="js_libs/util.js"></script>
  <script type="text/javascript" src="js_libs/printf.js"></script>
  <script type="text/javascript" src="js_libs/strftime.min.js"></script>
  <script type="text/javascript" src="js_libs/parsequery.js"></script>
  <script type="text/javascript" src="js_libs/underscore.min.js"></script>

  <script type="text/javascript" src="js_libs/marked.min.js"></script>
  <script type="text/javascript" src="js_libs/uidash.js"></script>

  <script type="text/javascript" src="https://cpee.org/js_libs/relaxngui.js"></script>
  <script type="text/javascript" src="https://cpee.org/js_libs/custommenu.js"></script>

  <script type="text/javascript" src="js/wfadaptor.js"></script>
  <link rel="stylesheet" href="css/wfadaptor.css" type="text/css" />

  <script type="text/javascript" src="themes/base.js"></script>

  <script type="text/javascript" src="js/extended_columns.js"></script>
  <link rel="stylesheet" href="css/extended_columns-label.css" type="text/css" />
  <link rel="stylesheet" href="css/extended_columns-svg.css" type="text/css" />

  <link rel="stylesheet" href="js_libs/uidash.css" type="text/css">
  <link rel="stylesheet" href="js_libs/relaxngui.css" type="text/css">
  <link rel="stylesheet" href="css/ui.css" type="text/css">
  <link rel="stylesheet" href="css/globalui_cpee.css" type="text/css">

  <!-- libs, do not modify. When local than load local libs. -->


  <!-- <script type="text/javascript" src="/js_libs/build-bpmn.js"></script> -->

  <link rel="stylesheet" href="https://cpee.org/js_libs/custommenu.css" type="text/css" />

  <!-- modelling ui -->
  <script type="text/javascript" src="js/wfadaptor.js"></script>
  <link rel="stylesheet" href="css/wfadaptor.css" type="text/css" />
  <script type="text/javascript" src="themes/base.js"></script>

  <script type="text/javascript" src="js/extended_columns.js"></script>
  <link rel="stylesheet" href="css/extended_columns-label.css" type="text/css" />
  <link rel="stylesheet" href="css/extended_columns-svg.css" type="text/css" />

  <!-- Flos Stuff -->
  <!-- <script type="text/javascript" src="js/structured.js"></script> -->
  <!-- <style type="text/css">
    @font-face {
      font-family: TencentSans;
      src: url("chrome-extension://lkjkfecdnfjopaeaibboihfkmhdjmanm/static/fonts/TencentSans.woff2");
    }
  </style> -->

  <!-- my libs-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- my scripts - DB simulation -->
  <script src="js/db_documents.js"></script>
  <script src="js/db_models.js"></script>
  <script src="js/db_traces.js"></script>
  <!-- my ui-->
  <link rel="stylesheet" href="css/myui.css" type="text/css" />

</head>
<body data-defaultconfig="index.json" is="x-ui-" data-names="3">

  <ui-rest style="z-index: 2;">
    <ui-content>
      <!-- Left: Document Panel -->
      <ui-rest style="flex:2;">
        <!-- Document List Pane -->
        <ui-tabbed style="z-index: 2;">
          <ui-tabbar>
            <ui-tab class="switch"></ui-tab>
            <ui-tab class="" data-tab="documents" id="tabdocuments" style="flex: 1;">Documents</ui-tab>
          </ui-tabbar>
          <ui-content>
            <ui-area data-belongs-to-tab="documents" id="areadocuments">
              <ul id="documentList">
              </ul>
              <label for="documentsInput">Choose documents to upload</label>
              <input type="file" id="documentsInput" multiple />
            </ui-area>
          </ui-content>
        </ui-tabbed>
        <!-- Text Action Bar -->
        <ui-area id="traceLayer" style="z-index: 1;"></ui-area>
        <ui-area id="temporarySelectionsLayer" style="z-index: 1;"></ui-area>
        <button id="deleteSelectionButton"
          style="display:none; position:absolute;  z-index:3; width: 24px; height: 24px; background-color: red; color: white;border: none; border-radius: 50%; font-weight: bold;cursor: pointer;">X</button>

        <!-- Document Viewer -->
        <ui-rest class="panel" style="margin:0.5em;">

          <ui-content>

            <ui-area id="documentContent">

            </ui-area>
          </ui-content>

          <div class="bottom-bar">
            <div class="button-group">
              <button id="generateButton" style="display:none;">Generate</button>
              <button id="regenerateButton" style="display:none;">Regenerate</button>
            </div>
          </div>
        </ui-rest>
      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Middle: Current Model Panel -->
      <ui-rest class="panel" style="flex:2; margin: .5em 0;">
        <div id="activeModelName"></div>
        <ui-content>
          <div id='activeModelGrid'>
            <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink"
              id='activeModelCanvas' width='1' height='1'></svg>
          </div>

          <div id="relaxngworker"></div>
        </ui-content>
        <!-- Model Action Bar -->
        <div id="generatedModelActionBar" class="bottom-bar" style="visibility: hidden;">
          <div class="button-group">
            <button id="cancelButton">Cancel</button>
            <button id="keepButton">Keep</button>
          </div>
        </div>

      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Right: Models Panel-->

      <ui-rest style="flex:1; margin:0.5em; padding: .2em;" class="panel">
        <ui-tab>Models</ui-tab>
        <ui-rest>
          <ui-content>
            <ui-area id="models"></ui-area>
          </ui-content>

        </ui-rest>
      </ui-rest>

    </ui-content>
  </ui-rest>
  <script>
    const $window = $(window);
    const $document = $(document);
    const $documentsInput = $('#documentsInput');
    const $documentList = $('#documentList');

    const $documentContent = $('#documentContent');
    const $traceLayer = $('#traceLayer');
    const $temporarySelectionsLayer = $('#temporarySelectionsLayer');
    const $deleteSelectionButton = $('#deleteSelectionButton');
    const $generateButton = $('#generateButton');
    const $regenerateButton = $('#regenerateButton');
    const $keepButton = $('#keepButton');
    const $cancelButton = $('#cancelButton');

    let db;
    let documentList = [];
    let activeDocId = null;
    let traces = [];
    let models = [];
    let activeModel = null;


    let temporarySelections = [];

    var es;
    var suspended_redrawing = false;
    var skip_location = false;
    var myid = ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
    var paths = '#dat_details input, #dat_details textarea, #dat_details select, #dat_details button, #dat_details [contenteditable], #dat_dataelements input, #dat_dataelements textarea, #dat_dataelements select, #dat_dataelements button, #dat_dataelements [contenteditable], #dat_endpoints input, #dat_endpoints textarea, #dat_endpoints select, #dat_endpoints button, #dat_endpoints [contenteditable], #dat_attributes input, #dat_attributes textarea, #dat_attributes select, #dat_attributes button, #dat_attributes [contenteditable]';
    var loading = false;
    var subscription;
    var subscription_state = 'less';
    var graph_changed = new Event("graph:changed", { "bubbles": true, "cancelable": false });
    var graph_theme = null;
    var graph_position = null;
    var graph_highlight = null;
    var graph_highlight_tasks = []
    var graph_highlight_color = null;
    var model_loaded = new Event("model:loaded", { "bubbles": true, "cancelable": false });
    var save = {};
    save['endpoints'] = undefined;
    save['dataelements'] = undefined;
    save['attributes'] = undefined;
    save['attributes_raw'] = {};

    var node_state = {};
    var debug = false;

    function global_init() {
      suspended_redrawing = false;
      loading = false;
      subscription = undefined;
      subscription_state = 'less';
      save['states'] = {};
      save['state'] = "ready";
      save['dsl'] = undefined;
      save['activity_red_states'] = {}
      save['graph'] = undefined;
      save['graph_theme'] = undefined;
      save['graph_adaptor'] = undefined;
      save['endpoints_cache'] = {};
      save['endpoints_list'] = {};
      save['details'] = undefined;
      save['details_target'] = {};
      save['instance_pos'] = [];
      save['modeltype'] = 'CPEE';
      save['modifiers'] = {};
      save['modifiers_active'] = {};
      save['modifiers_additional'] = {};
      save['resources'] = undefined;
      node_state = {};
    }

    global_init();


    function format_visual_forms() {
      if (save['state'] != "ready" && save['state'] != "stopped") {
        $(paths).each(function (k, e) {
          if ($(e).attr('contenteditable')) { $(e).attr('contenteditable', 'false'); }
          $(e).attr('disabled', 'disable');
        });
      } else {
        $(paths).each(function (k, e) {
          if ($(e).attr('contenteditable')) { $(e).attr('contenteditable', 'true'); }
          $(e).removeAttr('disabled');
        });
      }
    }
    // disable all input, also check themes
    format_visual_forms();


    function add_ui_pos(e) {
      ui_pos(e, function (coll) {
        coll.push([$(e).attr('id'), e.nodeName == 'stop' ? 'after' : 'at']);
        return coll;
      });
    }

    function del_ui_pos(e) {
      ui_pos(e, function (coll) {
        coll.splice(coll.findIndex((ele) => ele[0] == $(e).attr('id')), 1);
        return coll;
      });
    }


    function ui_pos(e, bl) {
      var url = $("body").attr("current-instance");
      var coll = [];
      $(
        "g.element.primitive > g.activities.active, g.element.primitive > g.activities.passive"
      ).each(function (a, b) {
        coll.push([
          $(b).parent().attr("element-id"),
          $(b).parent().attr("element-type") == "stop" ? "after" : "at",
        ]);
      });
      coll = bl(coll);
      var vals = "";
      $(coll).each(function (k, ele) {
        vals += "<" + ele[0] + ">" + ele[1] + "</" + ele[0] + ">";
      });
      vals =
        "<positions xmlns='http://cpee.org/ns/properties/2.0'>" +
        vals +
        "</positions>";
      $.ajax({
        type: "PUT",
        url: url + "/properties/positions/",
        contentType: "application/xml",
        headers: {
          "Content-ID": "positions",
          "CPEE-Event-Source": myid,
        },
        data: vals,
        success: monitor_instance_pos,
        error: report_failure,
      });
    }


    function monitor_instance_pos() {

      if (graph_position && graph_position == "false") {
        save["instance_pos"] = [];
        format_visual_clear();
        format_instance_pos();
        return;
      }
      var url = $("body").attr("current-instance");
      $.ajax({
        type: "GET",
        url: url + "/properties/positions/",
        success: function (res) {
          save["instance_pos"] = $("positions > *", res);
          format_visual_clear();
          format_instance_pos();
        },
      });
    }

    function report_failure() { }




    const connectDB = () => {
      return new Promise((resolve, reject) => {
        const dbReq = indexedDB.open("MyDB", 1);
        dbReq.onupgradeneeded = function (event) {
          const db = event.target.result;
          // db.deleteObjectStore("models");
          // db.deleteObjectStore("documents");
          // db.deleteObjectStore("traces");
          if (!db.objectStoreNames.contains("documents")) {
            db.createObjectStore("documents", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("models")) {
            db.createObjectStore("models", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("traces")) {
            const traceStore = db.createObjectStore("traces", {
              keyPath: "id",
              autoIncrement: true,
            });
            traceStore.createIndex("document_id", "document_id", { unique: false });
            traceStore.createIndex("model_id", "model_id", { unique: false });
          }

        };

        dbReq.onsuccess = function (event) {
          db = event.target.result;
          resolve(db);
        };
        dbReq.onerror = function (event) {
          console.error('Database error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    };

    const loadDocumentList = async () => {
      documentList = await getDocumentList(db);
      documentList.forEach(doc => {
        const $li = $("<li>").text(doc.name);
        $li.attr("data-docid", String(doc.id));
        $li.on("click", onDocumentSelect);
        $documentList.append($li);
        // const $option = $("<option>").val(doc.id).text(doc.name);
        // $('#documentListSelect').append($option);
      });
    };

    const loadTraces = async () => {
      for (const doc of documentList) {
        const newTraces = await getTracesByDocumentId(db, doc.id);
        traces = [...traces, ...newTraces];
      }
    };

    const loadModels = async () => {
      for (const trace of traces) {
        const model = await getModelById(db, trace.model_id);
        models.push(model);
        await renderModelInList(model);
      }
    };

    const onDocumentSelect = async (event) => {
      event.stopPropagation();
      const docId = $(event.currentTarget).data('docid');
      setActiveDocument(docId);
    };

    const setActiveDocument = async (docId) => {
      if (docId !== activeDocId) {
        $temporarySelectionsLayer.empty();
        activeDocId = docId;
        $documentList.children().each((index, element) => {
          const $element = $(element);
          if ($element.data('docid') === docId) {
            $element.addClass("active");
          } else {
            $element.removeClass("active");
          }
        });
        await loadDocument(docId);

        const modelTraces = traces.filter(trace => trace.document_id === docId);
        if (modelTraces.length > 0) {
          modelTraces.forEach(trace => renderTraceInDocument(trace));
        }

      }
    };
    const renderTraceInDocument = (trace) => {
      renderRanges(trace.segments, trace.model_id);
    };
    const loadDocument = async (docId) => {
      const content = await getDocumentContentById(db, docId);
      const htmlContent = new DOMParser().parseFromString(content, "text/html").body.innerHTML;
      $documentContent.html(htmlContent || '');

    };

    async function getFileContentInHTML(file) {
      let fileContent = "";
      if (file.type === "application/pdf") {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let pdfText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          fileContent += content.items.map(item => item.str).join(" ") + "\n";
        }
      }

      else if (
        file.type === "application/msword" ||
        file.name.endsWith(".doc") ||
        file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
        file.name.endsWith(".docx")
      ) {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        fileContent = new DOMParser().parseFromString(result.value, "text/html").body.innerHTML;
      }
      else {
        fileContent = await file.text();
      }
      return fileContent;
    }

    const setActiveModel = (modelId) => {
      if (modelId) {
        const model = models.find(m => m.id == modelId);
        activeModel = model;
        // console.log('Setting active model:', model);
        showModel(model);

        $('.model-container').removeClass('active');
        $(`.model-container[data-modelid="${modelId}"]`).addClass('active');
        $('.range-wrapper').removeClass("active");
        $(`.range-wrapper[data-modelid="${modelId}"]`).addClass("active");

      } else {
        clearModel();
      }

    };

    const showModel = (model) => {
      const { name: modelName, content: modelContent } = model;
      $('#activeModelName').text(modelName);

      var parser = new DOMParser();
      const data = parser.parseFromString(modelContent, "application/xml");
      new WfAdaptor('themes/extended/theme.js', function (graphrealization) {
        graphrealization.draw_labels = (max, labels, dimensions, striped) => {
          draw_extended_columns(graphrealization, max, labels, dimensions, striped)
        };
        graphrealization.set_svg_container($('#activeModelCanvas'));
        graphrealization.set_label_container($('#activeModelGrid'));
        graphrealization.set_description($(data), true);
      });
    };

    const clearModel = () => {
      activeModel = null;
      $('#activeModelName').text("");
      // console.log('Clearing active model canvas');
      $('#activeModelCanvas').empty();

    };

    const clearTemporarySelections = () => {
      temporarySelections = [];
      $temporarySelectionsLayer.empty();
    };

    const onModelSelect = async (event) => {
      event.stopPropagation();
      var target = $(event.currentTarget);
      target.addClass("active");
      // $('#models').children().not(target).removeClass('active');
      target.siblings().removeClass('active');
      const modelId = target.data('modelid');

      // if (modelId) {
      //   const model = await getModelById(db, modelId);
      //   setActiveModel(model);
      // }
      // const modelTrace = await getTraceByModelId(db, modelId);
      // await setActiveDocument(modelTrace.document_id);

      // renderRanges(modelTrace.segments);
      // renderSerializedRange
    };

    const renderModelInList = async ({ id: modelId, name: modelName, content: modelContent, svg: svgContent }) => {
      var gridId = `modelGrid_${modelId}`;
      var canvasId = `modelCanvas_${modelId}`;
      const $modelsArea = $("#models");
      const $modelContainer = $("<div>").addClass("model-container").attr("data-modelid", modelId);
      $modelContainer.text(`${modelName}`);
      $modelsArea.append($modelContainer);
      const $gridDiv = $("<div>").attr("id", gridId);

      const svgData = new DOMParser().parseFromString(svgContent, "image/svg+xml").documentElement;
      $gridDiv.append(svgData);
      $gridDiv.append(svgData);
      $modelContainer.append($gridDiv);
      $modelContainer.on("click", (e) => {
        e.stopPropagation();
        setActiveModel(modelId);
      });

    };

    const createSampleModel = async () => {
      const resp = await fetch('sample_model.xml');
      if (!resp.ok) {
        console.error('Failed to load sample_model.xml:', resp.status, resp.statusText);
        return;
      }
      return await resp.text();
    };

    const generateModel = async () => {
      const selectedText = temporarySelections.map(range => range.toString()).join(' ');
      // console.log('Generating model for selected text:', selectedText);
      generatedModel = await createSampleModel();
      var model = {
        name: `Model_${Date.now()}`,
        content: generatedModel,
      };
      activeModel = model;
      showModel(model);
      $("#generatedModelActionBar").css("visibility", "visible");
    };

    function getXPath(node, root = document.getElementById("documentContent")) {
      if (node === root) return '/';
      const path = [];
      let cur = node;
      while (cur && cur !== root) {
        const idx = Array.prototype.indexOf.call(cur.parentNode.childNodes, cur);
        path.unshift(idx);
        cur = cur.parentNode;
      }
      return '/' + path.join('/');
    }

    /** 从 XPath 获取节点 */
    function getNodeByXPath(path, root = document.getElementById("documentContent")) {
      const parts = path.split('/').filter(Boolean);
      let node = root;
      for (const idx of parts) {
        const i = parseInt(idx, 10);
        if (!node || !node.childNodes[i]) return null;
        node = node.childNodes[i];
      }
      return node;
    }

    const serializeRange = (range) => {
      return {
        id: range.id,
        // color: h.color,
        startXPath: getXPath(range.startContainer),
        startOffset: range.startOffset,
        endXPath: getXPath(range.endContainer),
        endOffset: range.endOffset,
      };
    };

    const deserializeRange = (serializedRange) => {
      const startNode = getNodeByXPath(serializedRange.startXPath);
      const endNode = getNodeByXPath(serializedRange.endXPath);
      const range = document.createRange();
      range.setStart(startNode, serializedRange.startOffset);
      range.setEnd(endNode, serializedRange.endOffset);
      return range;
    };

    const renderSerializedRange = (serializedRange) => {
      const range = deserializeRange(serializedRange);
      renderRange(range);
    };

    const renderRanges = (serializedRanges, modelId) => {
      // $temporarySelectionsLayer.empty();
      serializedRanges.forEach((serializedRange) => {
        const range = deserializeRange(serializedRange);
        renderRange(range, modelId);
      });
    };

    const renderRange = (range, modelId) => {

      const rangeId = range.id || Date.now();
      const $rangeDiv = $('<div>')
        .attr('id', rangeId)
        .attr('data-modelid', modelId || '')
        .addClass('range-wrapper')
        .css({
          top: `${range.getBoundingClientRect().top + window.scrollY}px`,
          left: `${range.getBoundingClientRect().left + window.scrollX}px`,
          width: `${range.getBoundingClientRect().width}px`,
          height: `${range.getBoundingClientRect().height}px`,
        })
        ;

      const $rangeRect = $('<div>').addClass('range-rect');

      // console.log('Highlighting range:', range.toString());
      const rects = range.getClientRects();
      for (const rect of rects) {
        const $rectDiv = $rangeRect.clone();
        $rectDiv.css({
          top: `${rect.top + window.scrollY}px`,
          left: `${rect.left + window.scrollX}px`,
          width: `${rect.width}px`,
          height: `${rect.height}px`,
        }).on('click', onRangeSelect);
        $rangeDiv.append($rectDiv);
      }

      if (modelId) {
        const lastIndex = rects.length - 1;
        const lastRect = rects[lastIndex];
        const modelName = models.find(m => m.id === modelId)?.name || `Model ${modelId}`;
        const labelSpan = $('<span>').attr('data-modelid', modelId).addClass('label-span').text(`${modelName}`).css({
          top: `${lastRect.top + window.scrollY - 10}px`,
          left: `${lastRect.right + window.scrollX}px`,
        }).on('click', onModelLabelSelect);
        $rangeDiv.append(labelSpan);
        $traceLayer.append($rangeDiv);
      } else {
        $temporarySelectionsLayer.append($rangeDiv);
      }

    };

    const onModelLabelSelect = (event) => {
      event.stopPropagation();
      const $target = $(event.currentTarget);
      const modelId = $target.attr('data-modelid');
      setActiveModel(modelId);
      // Handle model label selection logic here
    };

    const onRangeSelect = (event) => {
      event.stopPropagation();
      const $target = $(event.currentTarget).parent();
      $target.addClass("selected");
      const rangeId = $target.attr('id');
      $target.siblings().removeClass('selected');
      // Handle range selection logic here
      console.log('Range selected:', rangeId);
      const rangeBoundingRect = $target[0].getBoundingClientRect();

      $document.one('mousedown', () => {
        $deleteSelectionButton.hide();
        $target.removeClass('selected');
      });

      $deleteSelectionButton.show().css({
        top: `${rangeBoundingRect.top + window.scrollY - 12}px`,
        left: `${rangeBoundingRect.right + window.scrollX - 12}px`,
      }).on('click', () => {
        // Remove range from highlightedRanges and temporarySelections
        highlightedRanges = highlightedRanges.filter(r => r.id !== rangeId);
        temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
        // Remove the highlight from the UI
        $target.remove();
        $deleteSelectionButton.hide();
      });
    };

    /*const deleteRangeById = (rangeId) => {
      highlightedRanges = highlightedRanges.filter(r => r.id !== rangeId);
      temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
      $temporarySelectionsLayer.find(`#${rangeId}`).remove();
    };

    const clearRangeSelection = () => {
      $deleteSelectionButton.hide();
      $temporarySelectionsLayer.find('.range-wrapper.active').removeClass('active');
    };*/

    const rerenderAllSelections = () => {
      $temporarySelectionsLayer.empty();
      highlightedRanges.forEach((range) => {
        renderSerializedRange(range);
      });
      temporarySelections.forEach((range) => {
        renderRange(range);
      });
    };

    // const getXPath = (node, root = document.getElementById("documentContent")) => {
    //   // const paths = [];
    //   // for (; node && node !== root; node = node.parentNode) {
    //   //   let index = 0;
    //   //   let sibling = node.previousSibling;
    //   //   while (sibling) {
    //   //     if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === node.nodeName) {
    //   //       index++;
    //   //     }
    //   //     sibling = sibling.previousSibling;
    //   //   }
    //   //   const tagName = node.nodeType === Node.ELEMENT_NODE ? node.nodeName : 'text()';
    //   //   const pathIndex = index ? `[${index + 1}]` : '';
    //   //   paths.unshift(`${tagName}${pathIndex}`);
    //   // }
    //   // return paths.length ? '/' + paths.join('/') : null;

    //   const path = [];
    //   while (node && node !== root) {
    //     const index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
    //     path.unshift(index);
    //     node = node.parentNode;

    //     return '/' + path.join('/');
    //   }
    // };

    // const getNodeByXPath = (path, root = document.getElementById("documentContent")) => {
    //   // const parts = path.split('/').filter(Boolean);
    //   // let node = root;
    //   // for (const part of parts) {
    //   //   let tagName = part;
    //   //   let index = 0;
    //   //   const match = part.match(/(.*)\[(\d+)\]$/);
    //   //   if (match) {
    //   //     tagName = match[1];
    //   //     index = parseInt(match[2], 10) - 1;
    //   //   }
    //   //   let count = -1;
    //   //   let found = false;
    //   //   for (const child of node.childNodes) {
    //   //     if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === tagName) {
    //   //       count++;
    //   //       if (count === index) {
    //   //         node = child;
    //   //         found = true;
    //   //         break;
    //   //       }
    //   //     }
    //   //   }
    //   //   return found ? node : null;
    //   // };
    //   const parts = path.split('/').filter(Boolean);
    //   let node = root;
    //   for (const idx of parts) {
    //     const i = parseInt(idx, 10);
    //     if (!node || !node.childNodes[i]) return null;
    //     node = node.childNodes[i];
    //   }
    //   return node;
    // };

    const handleTextSelection = () => {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      if (range.collapsed) return;
      // if (!content.contains(range.commonAncestorContainer)) return;
      if (activeModel) {
        $regenerateButton.show();
      } else {
        $generateButton.show();
      }
      const clonedRange = range.cloneRange();
      clonedRange.id = Date.now();
      temporarySelections.push(clonedRange);
      renderRange(clonedRange);
      selection.removeAllRanges();
      // if (selection && selection.rangeCount > 0) {
      //   const range = selection.getRangeAt(0); // Get the selected range
      //   const startOffset = range.startOffset; // Start position of the selection
      //   const endOffset = range.endOffset; // End position of the selection

      //   // Get the parent node's text content (assumes the selection is within the `p` tag)
      //   const parentNode = range.startContainer.parentNode;
      //   // if (parentNode && parentNode.tagName === "P") {
      //   //   const fullText = parentNode.textContent;
      //   //   // Split the text into before, selected, and after parts
      //   //   // beforeSelection.value = text.slice(0, startOffset);
      //   //   store.selectedText = text.slice(startOffset, endOffset);
      //   //   // afterSelection.value = text.slice(endOffset);
      //   // }
      // }

    };

    $document.ready(async () => {
      // await connectDB();
      // await loadDocumentList();
      // await loadTraces();
      // await loadModels();

      // if (documentList.length) {
      //   setActiveDocument(documentList[documentList.length - 1]?.id);
      // }
      generateModel();
    });

    $documentsInput.on("change", async (event) => {
      for (const file of event.target.files) {
        if (!file) continue;
        const content = await getFileContentInHTML(file);
        // Store document in IndexedDB
        const documentId = await createDocument(db, file.name, content);
        const $ul = $("#documentList");
        const $li = $("<li>").text(file.name);
        $li.attr("data-docid", String(documentId));
        $li.on("click", onDocumentSelect);
        $ul.append($li);
        setActiveDocument(documentId);
      }
    });
    $documentContent.on("mouseup", handleTextSelection);
    $documentContent.on("scroll", rerenderAllSelections);
    $(window).on("resize", rerenderAllSelections);

    $generateButton.on("click", async () => {
      $generateButton.prop("disabled", true);
      generateModel();
    });

    $keepButton.on("click", async () => {

      const svgContent = $('#activeModelCanvas');
      const $svgCopy = svgContent.clone(false);
      $svgCopy.removeAttr('id');
      const svg = $svgCopy.prop('outerHTML');

      activeModel.svg = svg;
      const modelId = await createModel(db, activeModel);
      models.push({ ...activeModel, id: modelId });
      renderModelInList({ ...activeModel, id: modelId });
      clearModel();
      var trace = {
        document_id: activeDocId,
        model_id: modelId,
        segments: temporarySelections.map(range => serializeRange(range)),
      };
      await createTrace(db, trace);
      traces.push(trace);
      renderTraceInDocument(trace);
      clearTemporarySelections();

      $("#generatedModelActionBar").css("visibility", "hidden");

    });
    $cancelButton.on("click", () => {

      activeModel = null;
      $("#activeModelName").text("");
      // console.log('Clearing active model canvas');
      $("#activeModelCanvas").empty();
      $("#generatedModelActionBar").css("visibility", "hidden");

      // if (selectedText) {
      //   generateButton.prop("disabled", true);
      //   $("#generatedModelActionBar").css("visibility", "visible");
      //   showSampleModel();
      //   // alert(`Generating model for selected text:\n${selectedText}`);
      // } else {
      //   alert("No text selected.");
      // }
    });



  </script>
</body>
</html>