<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Document-Based Process Modeller</title>
  <!-- libs, do not modify. When local than load local libs. -->
  <script type="text/javascript" src="js_libs/jquery.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.browser.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svg.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.svgdom.min.js"></script>
  <script type="text/javascript" src="js_libs/vkbeautify.js"></script>
  <script type="text/javascript" src="js_libs/util.js"></script>
  <script type="text/javascript" src="js_libs/printf.js"></script>
  <script type="text/javascript" src="js_libs/strftime.min.js"></script>
  <script type="text/javascript" src="js_libs/parsequery.js"></script>
  <script type="text/javascript" src="js_libs/underscore.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.caret.min.js"></script>
  <script type="text/javascript" src="js_libs/jquery.cookie.js"></script>
  <script type="text/javascript" src="js_libs/marked.min.js"></script>

  <script type="text/javascript" src="js_libs/relaxngui.js"></script>

  <script type="text/javascript" src="js_libs/uidash.js"></script>



  <!-- modelling ui -->
  <script type="text/javascript" src="js/wfadaptor.js"></script>
  <link rel="stylesheet" href="css/wfadaptor.css" type="text/css" />


  <link rel="stylesheet" href="js_libs/uidash.css" type="text/css">
  <link rel="stylesheet" href="js_libs/relaxngui.css" type="text/css">

  <!-- custom stuff, play arround  -->
  <link rel="stylesheet" href="css/ui.css" type="text/css">
  <link rel="stylesheet" href="css/globalui_cpee.css" type="text/css">

  <!-- Flos Stuff -->
  <script type="text/javascript" src="js/structured.js"></script>
  <style type="text/css">
    @font-face {
      font-family: TencentSans;
      src: url("chrome-extension://lkjkfecdnfjopaeaibboihfkmhdjmanm/static/fonts/TencentSans.woff2");
    }
  </style>

  <!-- my libs-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <!-- my scripts - DB simulation -->
  <script src="js/db_documents.js"></script>
  <script src="js/db_models.js"></script>
  <script src="js/db_traces.js"></script>

  <!-- my ui-->
  <link rel="stylesheet" href="css/myui.css" type="text/css" />

</head>
<body data-defaultconfig="index.json" is="x-ui-" data-names="3">

  <ui-rest style="z-index: 2;">
    <ui-content>
      <!-- Left: Document Panel -->
      <ui-rest style="flex:2;">
        <!-- Document List Pane -->
        <ui-tabbed style="z-index: 2;">
          <ui-tabbar>
            <ui-tab class="switch"></ui-tab>
            <ui-tab class="" data-tab="documents" id="tabdocuments" style="flex: 1;">Documents</ui-tab>
          </ui-tabbar>
          <ui-content>
            <ui-area data-belongs-to-tab="documents" id="areadocuments">
              <ul id="documentList">

              </ul>
              <label for="documentsInput">Choose documents to upload</label>
              <input type="file" id="documentsInput" multiple />
            </ui-area>
          </ui-content>
        </ui-tabbed>
        <!-- Text Action Bar -->
        <ui-area id="highlightLayer" style="z-index: 1;"></ui-area>
        <button id="deleteSelectionButton"
          style="display:none; position:absolute;  z-index:3; width: 24px; height: 24px; background-color: red; color: white;border: none; border-radius: 50%; font-weight: bold;cursor: pointer;">X</button>
        <!-- Document Viewer -->
        <ui-rest class="panel" style="margin:0.5em;">

          <ui-content>

            <ui-area id="documentContent">

            </ui-area>
          </ui-content>

          <div class="bottom-bar">
            <div class="button-group">
              <button id="generateButton" disabled>Generate</button>
            </div>
          </div>
        </ui-rest>
      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Middle: Current Model Panel -->
      <ui-rest class="panel" style="flex:2; margin: .5em 0;">
        <div id="activeModelName"></div>
        <ui-content>
          <div id='activeModelGrid'>
            <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink"
              id='activeModelCanvas' width='1' height='1'></svg>
          </div>
        </ui-content>
        <!-- Model Action Bar -->
        <div id="generatedModelActionBar" class="bottom-bar" style="visibility: hidden;">
          <div class="button-group">
            <button id="cancelButton">Cancel</button>
            <button id="keepButton">Keep</button>
          </div>
        </div>

      </ui-rest>
      <ui-resizehandle></ui-resizehandle>
      <!-- Right: Models Panel-->
      <ui-rest style="flex:1; margin:0.5em; padding: .2em;" class="panel">

        <ui-tab>Models</ui-tab>
        <!-- <select id="documentListSelect">
          <option value="">-- Select a Document --</option>
        </select> -->
        <ui-rest>
          <ui-content>
            <ui-area id="models"></ui-area>
          </ui-content>

        </ui-rest>
        <!-- <div id='activeModelGrid'>
          <svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:x="http://www.w3.org/1999/xlink" id='activeModelCanvas'
            width='1' height='1'></svg>
        </div> -->
      </ui-rest>

    </ui-content>
  </ui-rest>
  <script>
    const $window = $(window);
    const $document = $(document);
    const $documentsInput = $('#documentsInput');
    const $documentList = $('#documentList');
    const $highlightLayer = $('#highlightLayer');
    const $documentContent = $('#documentContent');
    const $deleteSelectionButton = $('#deleteSelectionButton');
    const $generateButton = $('#generateButton');
    const $keepButton = $('#keepButton');
    const $cancelButton = $('#cancelButton');

    let db;
    let documentList = [];
    let activeDocId = null;
    let traces = [];
    let models = [];
    let activeModel = null;

    let highlightedRanges = [];
    let activeModelRanges = [];
    let temporarySelections = [];

    const connectDB = () => {
      return new Promise((resolve, reject) => {
        const dbReq = indexedDB.open("MyDB", 1);
        dbReq.onupgradeneeded = function (event) {
          const db = event.target.result;
          // db.deleteObjectStore("models");
          // db.deleteObjectStore("documents");
          // db.deleteObjectStore("traces");
          if (!db.objectStoreNames.contains("documents")) {
            db.createObjectStore("documents", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("models")) {
            db.createObjectStore("models", {
              keyPath: "id",
              autoIncrement: true,
            });
          }
          if (!db.objectStoreNames.contains("traces")) {
            const traceStore = db.createObjectStore("traces", {
              keyPath: "id",
              autoIncrement: true,
            });
            traceStore.createIndex("document_id", "document_id", { unique: false });
            traceStore.createIndex("model_id", "model_id", { unique: false });
          }

        };

        dbReq.onsuccess = function (event) {
          db = event.target.result;
          resolve(db);
        };
        dbReq.onerror = function (event) {
          console.error('Database error:', event.target.errorCode);
          reject(event.target.errorCode);
        };
      });
    };

    const loadDocumentList = async () => {
      documentList = await getDocumentList(db);
      documentList.forEach(doc => {
        const $li = $("<li>").text(doc.name);
        $li.attr("data-docid", String(doc.id));
        $li.on("click", onDocumentSelect);
        $documentList.append($li);

        // const $option = $("<option>").val(doc.id).text(doc.name);
        // $('#documentListSelect').append($option);
      });
    };

    const loadTraces = async () => {
      for (const doc of documentList) {
        const newTraces = await getTracesByDocumentId(db, doc.id);
        traces = [...traces, ...newTraces];
      }
    };

    const loadModels = async () => {
      for (const trace of traces) {
        const model = await getModelById(db, trace.model_id);
        models.push(model);
        await renderModel(model);
      }
    };

    const onDocumentSelect = async (event) => {
      event.stopPropagation();
      const docId = $(event.currentTarget).data('docid');
      setActiveDocument(docId);
    };

    const setActiveDocument = async (docId) => {
      if (docId !== activeDocId) {
        $highlightLayer.empty();
        activeDocId = docId;
        $documentList.children().each((index, element) => {
          const $element = $(element);
          if ($element.data('docid') === docId) {
            $element.addClass("active");
          } else {
            $element.removeClass("active");
          }
        });
        await loadDocument(docId);

        const modelTraces = traces.filter(trace => trace.document_id === docId);
        if (modelTraces.length > 0) {
          modelTraces.forEach(trace => {
            renderRanges(trace.segments, trace.model_id);
          });
        }

      }
    };

    const loadDocument = async (docId) => {
      const content = await getDocumentContentById(db, docId);
      const htmlContent = new DOMParser().parseFromString(content, "text/html").body.innerHTML;
      $documentContent.html(htmlContent || '');

    };

    async function getFileContentInHTML(file) {
      let fileContent = "";
      if (file.type === "application/pdf") {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        let pdfText = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          fileContent += content.items.map(item => item.str).join(" ") + "\n";
        }
      }

      else if (
        file.type === "application/msword" ||
        file.name.endsWith(".doc") ||
        file.type === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" ||
        file.name.endsWith(".docx")
      ) {
        const arrayBuffer = await file.arrayBuffer();
        const result = await mammoth.convertToHtml({ arrayBuffer });
        fileContent = new DOMParser().parseFromString(result.value, "text/html").body.innerHTML;
      }
      else {
        fileContent = await file.text();
      }
      return fileContent;
    }

    const setActiveModel = (model) => {

      activeModel = model
      const { name: modelName, content: modelContent } = model;
      $('#activeModelName').text(modelName);

      var parser = new DOMParser();
      const data = parser.parseFromString(modelContent, "application/xml");
      new WfAdaptor('themes/default/theme.js', function (graphrealization) {
        graphrealization.draw_labels = (max, labels, shift, striped) => {
          // console.log(JSON.stringify(labels, null, "  "));
        };
        graphrealization.set_svg_container($('#activeModelCanvas'));
        graphrealization.set_label_container($('#activeModelGrid'));
        graphrealization.set_description($(data), true);
      });
    };

    const onModelSelect = async (event) => {
      event.stopPropagation();
      var target = $(event.currentTarget);
      target.addClass("active");
      // $('#models').children().not(target).removeClass('active');
      target.siblings().removeClass('active');
      const modelId = target.data('modelid');

      if (modelId) {
        const model = await getModelById(db, modelId);
        setActiveModel(model);
      }
      const modelTrace = await getTraceByModelId(db, modelId);
      await setActiveDocument(modelTrace.document_id);

      renderRanges(modelTrace.segments);
      // renderSerializedRange
    };

    const renderModel = async ({ id: modelId, name: modelName, content: modelContent, svg: svgContent }) => {

      var gridId = `modelGrid_${modelId}`;
      var canvasId = `modelCanvas_${modelId}`;
      const $modelsArea = $("#models");
      const $modelContainer = $("<div>").addClass("model-container").attr("data-modelid", modelId);
      $modelContainer.text(`${modelName}`);
      $modelsArea.append($modelContainer);
      const $gridDiv = $("<div>").attr("id", gridId);

      const svgData = new DOMParser().parseFromString(svgContent, "image/svg+xml").documentElement;
      $gridDiv.append(svgData);
      $gridDiv.append(svgData);
      $modelContainer.append($gridDiv);
      $modelContainer.on("click", onModelSelect);

    };


    const createSampleModel = async () => {
      const resp = await fetch('Frames.xml');
      if (!resp.ok) {
        console.error('Failed to load Frames.xml:', resp.status, resp.statusText);
        return;
      }
      return await resp.text();
    };

    const generateModel = async () => {
      const selectedText = temporarySelections.map(range => range.toString()).join(' ');
      // console.log('Generating model for selected text:', selectedText);
      generatedModel = await createSampleModel();
      setActiveModel({ name: `Model_${models.length + 1}`, content: generatedModel });
      $("#generatedModelActionBar").css("visibility", "visible");
    };

    function getXPath(node, root = document.getElementById("documentContent")) {
      if (node === root) return '/';
      const path = [];
      let cur = node;
      while (cur && cur !== root) {
        const idx = Array.prototype.indexOf.call(cur.parentNode.childNodes, cur);
        path.unshift(idx);
        cur = cur.parentNode;
      }
      return '/' + path.join('/');
    }

    /** 从 XPath 获取节点 */
    function getNodeByXPath(path, root = document.getElementById("documentContent")) {
      const parts = path.split('/').filter(Boolean);
      let node = root;
      for (const idx of parts) {
        const i = parseInt(idx, 10);
        if (!node || !node.childNodes[i]) return null;
        node = node.childNodes[i];
      }
      return node;
    }

    const serializeRange = (range) => {
      return {
        // id: h.id,
        // color: h.color,
        startXPath: getXPath(range.startContainer),
        startOffset: range.startOffset,
        endXPath: getXPath(range.endContainer),
        endOffset: range.endOffset,
      };
    };

    const deserializeRange = (serializedRange) => {
      const startNode = getNodeByXPath(serializedRange.startXPath);
      const endNode = getNodeByXPath(serializedRange.endXPath);
      const range = document.createRange();
      range.setStart(startNode, serializedRange.startOffset);
      range.setEnd(endNode, serializedRange.endOffset);
      return range;
    };

    const renderSerializedRange = (serializedRange) => {
      const range = deserializeRange(serializedRange);
      highlightRange(range);
    };

    const renderRanges = (serializedRanges, modelId) => {
      // $highlightLayer.empty();
      serializedRanges.forEach((serializedRange) => {
        const range = deserializeRange(serializedRange);
        highlightRange(range, modelId);
      });
    };

    const highlightRange = (range, modelId) => {
      const $highlightLayer = $('#highlightLayer');
      const rangeId = range.id || Date.now();
      const $rangeDiv = $('<div>')
        .attr('id', rangeId)
        .addClass('highlight-wrapper')
        .css({
          top: `${range.getBoundingClientRect().top + window.scrollY}px`,
          left: `${range.getBoundingClientRect().left + window.scrollX}px`,
          width: `${range.getBoundingClientRect().width}px`,
          height: `${range.getBoundingClientRect().height}px`,
        })
        ;

      const $rangeRect = $('<div>').addClass('highlight-rect');

      // console.log('Highlighting range:', range.toString());
      const rects = range.getClientRects();
      for (const rect of rects) {
        const $rectDiv = $rangeRect.clone();
        $rectDiv.css({
          top: `${rect.top + window.scrollY}px`,
          left: `${rect.left + window.scrollX}px`,
          width: `${rect.width}px`,
          height: `${rect.height}px`,
        }).on('click', onRangeSelect);
        $rangeDiv.append($rectDiv);
      }

      if (modelId) {
        const lastIndex = rects.length - 1;
        const lastRect = rects[lastIndex];
        const modelName = models.find(m => m.id === modelId)?.name || `Model ${modelId}`;
        const labelSpan = $('<span>').attr('data-modelid', modelId).addClass('label-span').text(`${modelName}`).css({
          top: `${lastRect.top + window.scrollY - 10}px`,
          left: `${lastRect.right + window.scrollX}px`,
        }).on('click', onModelLabelSelect);
        $rangeDiv.append(labelSpan);
      }
      $highlightLayer.append($rangeDiv);
    };

    const onModelLabelSelect = (event) => {
      event.stopPropagation();
      const $target = $(event.currentTarget);
      const modelId = $target.attr('data-modelid');
      setActiveModel(models.find(m => m.id == modelId));
      // Handle model label selection logic here
    };

    const onRangeSelect = (event) => {
      event.stopPropagation();
      const $target = $(event.currentTarget).parent();
      $target.addClass("active");
      const rangeId = $target.attr('id');
      $target.siblings().removeClass('active');
      // Handle range selection logic here
      console.log('Range selected:', rangeId);
      const rangeBoundingRect = $target[0].getBoundingClientRect();

      $document.one('mousedown', () => {
        $deleteSelectionButton.hide();
        $target.removeClass('active');
      });

      $deleteSelectionButton.show().css({
        top: `${rangeBoundingRect.top + window.scrollY - 12}px`,
        left: `${rangeBoundingRect.right + window.scrollX - 12}px`,
      }).on('click', () => {
        // Remove range from highlightedRanges and temporarySelections
        highlightedRanges = highlightedRanges.filter(r => r.id !== rangeId);
        temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
        // Remove the highlight from the UI
        $target.remove();
        $deleteSelectionButton.hide();
      });
    };

    /*const deleteRangeById = (rangeId) => {
      highlightedRanges = highlightedRanges.filter(r => r.id !== rangeId);
      temporarySelections = temporarySelections.filter(r => r.id !== rangeId);
      $highlightLayer.find(`#${rangeId}`).remove();
    };

    const clearRangeSelection = () => {
      $deleteSelectionButton.hide();
      $highlightLayer.find('.highlight-wrapper.active').removeClass('active');
    };*/

    const rerenderAllSelections = () => {
      $highlightLayer.empty();
      highlightedRanges.forEach((range) => {
        renderSerializedRange(range);
      });
      temporarySelections.forEach((range) => {
        highlightRange(range);
      });
    };

    // const getXPath = (node, root = document.getElementById("documentContent")) => {
    //   // const paths = [];
    //   // for (; node && node !== root; node = node.parentNode) {
    //   //   let index = 0;
    //   //   let sibling = node.previousSibling;
    //   //   while (sibling) {
    //   //     if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName === node.nodeName) {
    //   //       index++;
    //   //     }
    //   //     sibling = sibling.previousSibling;
    //   //   }
    //   //   const tagName = node.nodeType === Node.ELEMENT_NODE ? node.nodeName : 'text()';
    //   //   const pathIndex = index ? `[${index + 1}]` : '';
    //   //   paths.unshift(`${tagName}${pathIndex}`);
    //   // }
    //   // return paths.length ? '/' + paths.join('/') : null;

    //   const path = [];
    //   while (node && node !== root) {
    //     const index = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
    //     path.unshift(index);
    //     node = node.parentNode;

    //     return '/' + path.join('/');
    //   }
    // };

    // const getNodeByXPath = (path, root = document.getElementById("documentContent")) => {
    //   // const parts = path.split('/').filter(Boolean);
    //   // let node = root;
    //   // for (const part of parts) {
    //   //   let tagName = part;
    //   //   let index = 0;
    //   //   const match = part.match(/(.*)\[(\d+)\]$/);
    //   //   if (match) {
    //   //     tagName = match[1];
    //   //     index = parseInt(match[2], 10) - 1;
    //   //   }
    //   //   let count = -1;
    //   //   let found = false;
    //   //   for (const child of node.childNodes) {
    //   //     if (child.nodeType === Node.ELEMENT_NODE && child.nodeName === tagName) {
    //   //       count++;
    //   //       if (count === index) {
    //   //         node = child;
    //   //         found = true;
    //   //         break;
    //   //       }
    //   //     }
    //   //   }
    //   //   return found ? node : null;
    //   // };
    //   const parts = path.split('/').filter(Boolean);
    //   let node = root;
    //   for (const idx of parts) {
    //     const i = parseInt(idx, 10);
    //     if (!node || !node.childNodes[i]) return null;
    //     node = node.childNodes[i];
    //   }
    //   return node;
    // };

    const handleTextSelection = () => {

      const selection = window.getSelection();

      if (!selection.rangeCount) return;
      const range = selection.getRangeAt(0);
      if (range.collapsed) return;
      // if (!content.contains(range.commonAncestorContainer)) return;

      $generateButton.prop("disabled", false);
      const clonedRange = range.cloneRange();
      clonedRange.id = Date.now();
      temporarySelections.push(clonedRange);
      highlightRange(clonedRange);
      selection.removeAllRanges();
      // if (selection && selection.rangeCount > 0) {
      //   const range = selection.getRangeAt(0); // Get the selected range
      //   const startOffset = range.startOffset; // Start position of the selection
      //   const endOffset = range.endOffset; // End position of the selection

      //   // Get the parent node's text content (assumes the selection is within the `p` tag)
      //   const parentNode = range.startContainer.parentNode;
      //   // if (parentNode && parentNode.tagName === "P") {
      //   //   const fullText = parentNode.textContent;
      //   //   // Split the text into before, selected, and after parts
      //   //   // beforeSelection.value = text.slice(0, startOffset);
      //   //   store.selectedText = text.slice(startOffset, endOffset);
      //   //   // afterSelection.value = text.slice(endOffset);
      //   // }
      // }

    };

    $document.ready(async () => {
      await connectDB();
      await loadDocumentList();
      await loadTraces();
      await loadModels();

      if (documentList.length) {
        setActiveDocument(documentList[documentList.length - 1]?.id);
      }
      // highlightsScrollSync();
    });

    $documentsInput.on("change", async (event) => {
      for (const file of event.target.files) {
        if (!file) continue;
        const content = await getFileContentInHTML(file);
        // Store document in IndexedDB
        const documentId = await createDocument(db, file.name, content);
        const $ul = $("#documentList");
        const $li = $("<li>").text(file.name);
        $li.attr("data-docid", String(documentId));
        $li.on("click", onDocumentSelect);
        $ul.append($li);
        setActiveDocument(documentId);
      }
    });
    $documentContent.on("mouseup", handleTextSelection);
    $documentContent.on("scroll", rerenderAllSelections);
    $(window).on("resize", rerenderAllSelections);

    $generateButton.on("click", async () => {
      $generateButton.prop("disabled", true);
      generateModel();
    });

    $keepButton.on("click", async () => {

      const svgContent = $('#activeModelCanvas');
      const $svgCopy = svgContent.clone(false);
      $svgCopy.removeAttr('id');
      const svg = $svgCopy.prop('outerHTML');

      activeModel.svg = svg;
      const modelId = await createModel(db, activeModel);
      renderModel({ ...activeModel, id: modelId });
      await createTrace(db, {
        document_id: activeDocId,
        model_id: modelId,
        segments: temporarySelections.map(range => serializeRange(range)),
      });

      $("#generatedModelActionBar").css("visibility", "hidden");

    });
    $cancelButton.on("click", () => {

      activeModel = null;
      $("#activeModelName").text("");
      // console.log('Clearing active model canvas');
      $("#activeModelCanvas").empty();
      $("#generatedModelActionBar").css("visibility", "hidden");

      // if (selectedText) {
      //   generateButton.prop("disabled", true);
      //   $("#generatedModelActionBar").css("visibility", "visible");
      //   showSampleModel();
      //   // alert(`Generating model for selected text:\n${selectedText}`);
      // } else {
      //   alert("No text selected.");
      // }
    });



  </script>
</body>
</html>